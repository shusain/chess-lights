{"mappings":"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","sources":["src/ChessPieces/ChessPiece.ts","src/ChessPieces/Bishop.ts","src/ChessTile.ts","src/ChessPieces/Knight.ts","src/ChessPieces/Pawn.ts","src/ChessPieces/Rook.ts","src/ChessPieces/Queen.ts","src/ChessPieces/King.ts","src/ChessBoard.ts","src/RowPattern.ts","src/SequencePattern.ts","src/SnakePattern.ts","src/ChessLightsMain.ts"],"sourcesContent":["import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\n\n/**\n * Abstract Base Class for common properties/methods for all of the pieces\n */\nexport abstract class ChessPiece {\n  abstract pieceSymbol() : string\n\n  constructor(public currentTile:ChessTile = null, public color: \"white\" | \"black\" = \"white\") {}\n\n  abstract findValidMoves(boardState : ChessBoard) : Array<{ x: number; y: number; }>\n  \n  get direction() { return this.color === \"white\" ? 1 : -1 }\n\n  get myPos(){\n      return {\n        x: this.currentTile.x,\n        y: this.currentTile.y\n      }\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Bishop extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♝\" : \"♗\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n}","import { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessTile {\n    id: number\n    y: number\n    x: number\n    \n    isValidPosition: boolean\n\n    prevLight: ChessTile;\n    nextLight: ChessTile;\n\n    currentPiece:ChessPiece|null;\n\n    get tileBaseColor () {\n        return (this.id+(this.y%2))%2==0 ? \"black\" : \"white\"\n    }\n\n    constructor(id, x, y, public isOn=false, public hue=0, public saturation=100, public brightness=50) {\n        this.id = id\n        this.x = x\n        this.y = y\n    }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Knight extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♞\" : \"♘\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n    \n    let tileOne = boardState.getTileAtPosition(myPos.x+2, myPos.y+1)\n    let tileTwo = boardState.getTileAtPosition(myPos.x+1, myPos.y+2)\n    let tileThree = boardState.getTileAtPosition(myPos.x-2, myPos.y+1)\n    let tileFour = boardState.getTileAtPosition(myPos.x-1, myPos.y+2)\n    \n    let tileFive = boardState.getTileAtPosition(myPos.x-2, myPos.y-1)\n    let tileSix = boardState.getTileAtPosition(myPos.x-1, myPos.y-2)\n    let tileSeven = boardState.getTileAtPosition(myPos.x+2, myPos.y-1)\n    let tileEight = boardState.getTileAtPosition(myPos.x+1, myPos.y-2);\n\n    [tileOne,tileTwo,tileThree,tileFour,tileFive,tileSix,tileSeven,tileEight].forEach(tile=>{\n      // skip if the tile doesn't exist\n      if(!tile) return;\n      // \n      if(!tile.currentPiece || tile.currentPiece.color != this.color) {\n        validPositions.push(tile)\n      }\n    })\n\n\n    return validPositions\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Pawn extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♟︎\" : \"♙\";\n  \n  public hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos, direction} = this\n\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    \n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (tile.currentPiece && tile.currentPiece.color!=this.color)) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileTL,tileTR].forEach(tile=>addTilePositionIfValid(tile))\n\n    let pieceOneAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction)\n    if(!pieceOneAhead) {\n      validPositions.push({\n        x: myPos.x,\n        y: myPos.y+direction\n      })\n    }\n\n    // Pawn can move two spots if hasn't moved yet\n    if(!this.hasMoved) {\n      let twoPiecesAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction*2)\n      if(!twoPiecesAhead) {\n        validPositions.push({\n          x: myPos.x,\n          y: myPos.y+direction*2\n        })\n      }\n    }\n\n    return validPositions;\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Rook extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♜\" : \"♖\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    // Destructuring props of this\n    const {myPos} = this\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Queen extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♛\" : \"♕\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this;\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    return validPositions\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class King extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♚\" : \"♔\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n\n    const {myPos, direction} = this;\n\n    // Cardinal positions\n    let tileOneAbove = boardState.getTileAtPosition(myPos.x, myPos.y+direction)\n    let tileOneBelow = boardState.getTileAtPosition(myPos.x, myPos.y-direction)\n    let tileOneLeft = boardState.getTileAtPosition(myPos.x-1, myPos.y)\n    let tileOneRight = boardState.getTileAtPosition(myPos.x+1, myPos.y)\n\n    // Diaganol moves\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileBL = boardState.getTileAtPosition(myPos.x+direction, myPos.y-direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    let tileBR = boardState.getTileAtPosition(myPos.x-direction, myPos.y-direction)\n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (!tile.currentPiece || (tile.currentPiece && tile.currentPiece.color!=this.color))) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileOneAbove, tileOneBelow, tileOneLeft, tileOneRight, tileTL, tileBL, tileTR, tileBR].forEach(tile => {\n      addTilePositionIfValid(tile)\n    })\n    \n    return validPositions\n  }\n}","import Bishop from \"./ChessPieces/Bishop\";\nimport { ChessTile } from \"./ChessTile\"\nimport Knight from \"./ChessPieces/Knight\";\nimport Pawn from \"./ChessPieces/Pawn\";\nimport Rook from \"./ChessPieces/Rook\";\nimport Queen from \"./ChessPieces/Queen\";\nimport King from \"./ChessPieces/King\";\nimport { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessBoard {\n    boardTiles: Array<Array<ChessTile>> = []\n    flatTileList:Array<ChessTile> = []\n\n    counter = 0\n    currentPlayersTurn: \"white\" | \"black\" = \"white\"\n    selectedPiece : ChessPiece\n\n    getTileAtPosition(x:number, y:number): ChessTile|null {\n        try {\n            return this.boardTiles[y][x];\n        } catch(e) {\n            return null\n        }\n    }\n\n    selectPiece(x:number, y:number): ChessPiece|null {\n        // Don't return a piece if a tile has a piece, but the piece isn't the same color as the current player\n        this.selectedPiece = this.getPieceAtPosition(x,y)\n        console.log(this.selectedPiece)\n        return this.selectedPiece\n    }\n    \n    getPieceAtPosition(x:number, y:number): ChessPiece|null {\n        try {\n            return this.boardTiles[y][x].currentPiece\n        } catch(e){\n            return null\n        }\n    }\n\n    movePiece(fromTile:ChessTile, toTile:ChessTile):void {\n        console.log('moving piece',fromTile, toTile)\n\n        toTile.currentPiece = fromTile.currentPiece\n        \n        if(toTile.currentPiece instanceof Pawn) {\n            toTile.currentPiece.hasMoved = true\n        }\n\n        fromTile.currentPiece = null\n        toTile.currentPiece.currentTile = toTile\n    }\n\n    setupDataModel() {\n        for (let y = 0; y < 8; y++) {\n            this.makeRow(y)\n        }\n\n        // setup link list references between objects\n        let prevLight\n        for (let i = 0; i < this.flatTileList.length; i++) {\n            const currentLight = this.flatTileList[i];\n            currentLight.prevLight = prevLight\n            if(i < this.flatTileList.length - 1) {\n                currentLight.nextLight = this.flatTileList[i+1]\n            }\n        }\n\n        this.flatTileList[0].prevLight = this.flatTileList[this.flatTileList.length - 1]\n        this.flatTileList[this.flatTileList.length - 1].nextLight = this.flatTileList[0]\n    }\n\n    setupPiecesOnBoard() {\n        // White back row\n        this.boardTiles[0][0].currentPiece = new Rook(this.boardTiles[0][0])\n        this.boardTiles[0][7].currentPiece = new Rook(this.boardTiles[0][7])\n\n        this.boardTiles[0][1].currentPiece = new Knight(this.boardTiles[0][1])\n        this.boardTiles[0][6].currentPiece = new Knight(this.boardTiles[0][6])\n\n        this.boardTiles[0][2].currentPiece = new Bishop(this.boardTiles[0][2])\n        this.boardTiles[0][5].currentPiece = new Bishop(this.boardTiles[0][5])\n\n        this.boardTiles[0][3].currentPiece = new Queen(this.boardTiles[0][3])\n        this.boardTiles[0][4].currentPiece = new King(this.boardTiles[0][4])\n\n        \n        // Black back row\n        this.boardTiles[7][0].currentPiece = new Rook(this.boardTiles[7][0], \"black\")\n        this.boardTiles[7][7].currentPiece = new Rook(this.boardTiles[7][7], \"black\")\n\n        this.boardTiles[7][1].currentPiece = new Knight(this.boardTiles[7][1], \"black\")\n        this.boardTiles[7][6].currentPiece = new Knight(this.boardTiles[7][6], \"black\")\n\n        this.boardTiles[7][2].currentPiece = new Bishop(this.boardTiles[7][2], \"black\")\n        this.boardTiles[7][5].currentPiece = new Bishop(this.boardTiles[7][5], \"black\")\n\n        this.boardTiles[7][3].currentPiece = new King(this.boardTiles[7][3], \"black\")\n        this.boardTiles[7][4].currentPiece = new Queen(this.boardTiles[7][4], \"black\")\n\n        for(let x=0; x < 8; x++) {\n            // White pawns\n            this.boardTiles[1][x].currentPiece = new Pawn(this.boardTiles[1][x])\n\n            // Black pawns\n            this.boardTiles[6][x].currentPiece = new Pawn(this.boardTiles[6][x], \"black\")\n        }\n    }\n    \n    /**\n     * return Array of currently lit positions\n     */\n    findCurrentlyLit() {\n        return this.flatTileList.filter(element => element.isOn )\n    }\n\n    turnOffAll() {\n        this.flatTileList.forEach(light => light.isOn = false)\n    }\n\n    markAllInvalid() {\n        this.flatTileList.forEach(light => light.isValidPosition = false)\n    }\n\n    makeRow(rowNum: number) {\n        this.boardTiles[rowNum] = []\n\n        for (let x = 0; x < 8; x++) {\n            const newLightObject = new ChessTile(this.counter++, x, rowNum)\n\n            this.boardTiles[rowNum].push(newLightObject)\n\n            this.flatTileList.push(newLightObject)\n        }\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class RowPattern implements ILightPattern {\n    currentlyLitLightRow = 0\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        currentBoard.boardTiles[this.currentlyLitLightRow].forEach(lightData => lightData.isOn = true)\n        this.currentlyLitLightRow++\n        if(this.currentlyLitLightRow >= currentBoard.boardTiles.length) {\n            this.currentlyLitLightRow = 0\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SequencePattern implements ILightPattern {\n    firstRun = true\n    constructor() {\n    }\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        if(this.firstRun) {\n            currentBoard.turnOffAll()\n            currentBoard.flatTileList[0].isOn = true\n            this.firstRun = false\n        }\n        let currentlyLit = currentBoard.findCurrentlyLit()\n        \n        if(currentlyLit.length > 0) {\n\n            for (let i = currentlyLit.length - 1; 0 <= i; i--) {\n                const lightData = currentlyLit[i];\n                \n                lightData.isOn = false;\n                lightData.nextLight.isOn = true;\n            }\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SnakePattern implements ILightPattern {\n    snakeHead = 0\n    snakeLength = 12\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        let snakeHeadElm = currentBoard.flatTileList[this.snakeHead]\n        snakeHeadElm.isOn = true\n\n        let curLight = snakeHeadElm\n        for (let i = 0; i < this.snakeLength; i++) {\n            curLight = curLight.nextLight\n            curLight.isOn = true\n            if(i==0)\n                this.snakeHead = curLight.id\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\"\nimport { ILightPattern } from \"./ILightPattern\"\nimport { RowPattern } from \"./RowPattern\"\nimport { SequencePattern } from \"./SequencePattern\"\nimport { SnakePattern } from \"./SnakePattern\"\n\nexport class ChessLightsMain {\n    chessBoard:ChessBoard\n    mode: ILightPattern\n\n    constructor() {\n        // Waiting for page to be loaded to get the elemnets on the page and add listeners/setup the game\n        window.addEventListener('DOMContentLoaded', () => {\n\n            // Listener for the drop down menu\n            document.getElementById('mode').addEventListener('change', (event) => {\n                this.changeMode(event)\n            })\n\n            setInterval(() => {\n                this.updateDisplay()\n            }, 100)\n\n            this.chessBoard = new ChessBoard()\n            this.chessBoard.setupDataModel()\n            this.chessBoard.setupPiecesOnBoard()\n            this.buildBoard()\n            // this.mode = new SequencePattern()\n        });\n    }\n\n    /**\n     * Called on an interval to update the DOM elements that represent the board visually based on the board model\n     */\n    updateDisplay() {\n        if(this.mode) {\n            this.chessBoard = this.mode.updatePattern(this.chessBoard)\n        }\n\n        this.chessBoard.flatTileList.forEach(tile => {\n\n            let curTileElm = document.getElementById(`tile-${tile.id}`)\n            const onOrOffTile = tile.isOn ? 'on':'off'\n            curTileElm.className = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n            \n            if(tile.currentPiece) {\n                curTileElm.style.color = tile.currentPiece.color\n            }\n\n            let displayText = \"\"\n            if(tile.currentPiece) {\n                displayText = tile.currentPiece.pieceSymbol()\n            }\n\n            curTileElm.innerHTML = `${displayText}`\n        })\n    }\n\n    /**\n     * Method handles drop down change events and creates the corresponding light pattern/sequence handler.  Used primarily for prototyping LED patterns for LED chess board.\n     * \n     * @param event an event from the select/options dropdown, the event.target.value is used to determine which Pattern instance to create\n     */\n    changeMode(event) {\n        switch(event.target.value) {\n            case 'snake': this.mode = new SnakePattern()\n            break;\n            case 'sequence': this.mode = new SequencePattern()\n            break;\n            case 'row': this.mode = new RowPattern()\n            break;\n            case 'none': this.mode = null\n            break;\n        }\n    }\n\n    /**\n     * Clears out and rebuilds the DOM elements for the board based on the board model\n     * deals with finding valid moves and highlighting cells on the board based on the\n     * board model\n     */\n    buildBoard() {\n        let chessBoard = document.getElementById('chess-board')\n        \n        while (chessBoard.firstChild) {\n            chessBoard.removeChild(chessBoard.firstChild);\n        }\n\n        // Maps all the tiles row by row into DOM elements\n        const boardRowDOMElms = this.chessBoard.boardTiles\n            .map((tileRow) => {\n\n                // Maps all the cells of a given row into DOM elements\n                const cells = tileRow.map((tile) => {\n                    let tileDiv = document.createElement('div')\n                    tileDiv.className = `chess-tile ${tile.id % 2 == 0 ? 'even':'odd'}  ${tile.isOn ? 'on':'off'} tile-color-${tile.tileBaseColor}`\n                    tileDiv.id=`tile-${tile.id}`\n\n                    let tileClickHandler = () => {\n                        if(tile.isValidPosition) {\n                            this.chessBoard.movePiece(this.chessBoard.selectedPiece.currentTile, tile)\n                            this.chessBoard.turnOffAll();\n                            this.chessBoard.markAllInvalid();\n                            this.chessBoard.currentPlayersTurn = this.chessBoard.currentPlayersTurn === \"white\" ? \"black\" : \"white\";\n                        }\n                        else {\n                            let selectedPiece = this.chessBoard.selectPiece(tile.x, tile.y)\n                            let wasOn = tile.isOn;\n                            \n                            this.chessBoard.turnOffAll();\n                            \n                            if(selectedPiece) {\n                                tile.isOn = !wasOn\n                                if(tile.isOn) {\n                                    this.chessBoard.markAllInvalid();\n                                    let validMoves = selectedPiece.findValidMoves(this.chessBoard)\n    \n                                    validMoves.forEach(validMove => {\n                                        // Marking all the valid moves for the selected piece on the board\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isValidPosition = true\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isOn = true\n                                    })\n                                }\n                            }\n                        }\n                    }\n\n                    tileDiv.addEventListener('click', tileClickHandler)\n                    return tileDiv\n                })\n                let rowDiv = document.createElement('div')\n                rowDiv.className = 'row'\n                cells.forEach(cell => {rowDiv.appendChild(cell)})\n                return rowDiv\n            })\n        boardRowDOMElms.forEach(boardRowDOMElm => chessBoard.appendChild(boardRowDOMElm))\n        \n    }\n}\nnew ChessLightsMain()"],"names":["$b22d20f8eed3c195$export$57e01e9070034a96","currentTile","color","direction","this","myPos","x","y","$0d26fdf8bf377e35$export$2e2bcd8739ae039","findValidMoves","boardState","validPositions","i","j","curTile","getTileAtPosition","currentPiece","push","i1","j1","i2","j2","i3","j3","pieceSymbol","$19302002edd8d79c$export$a9149a6cae1863c8","tileBaseColor","id","isOn","hue","saturation","brightness","$4f1600a5f2f06aab$export$2e2bcd8739ae039","forEach","tile","$f1ffc8d94fc3f9eb$export$2e2bcd8739ae039","tileTL","tileTR","addTilePositionIfValid","getPieceAtPosition","hasMoved","$c374f64110df5620$export$2e2bcd8739ae039","$1ef2ac3924524536$export$2e2bcd8739ae039","i4","i5","i6","i7","$6364cc4a6fd49207$export$2e2bcd8739ae039","tileOneAbove","tileOneBelow","tileOneLeft","tileOneRight","tileBL","tileBR","$b07460e442fde56f$export$e27bc415f35efa4e","boardTiles","e","selectPiece","selectedPiece","console","log","movePiece","fromTile","toTile","setupDataModel","makeRow","flatTileList","length","currentLight","prevLight","nextLight","setupPiecesOnBoard","findCurrentlyLit","filter","element","turnOffAll","light","markAllInvalid","isValidPosition","rowNum","newLightObject","counter","currentPlayersTurn","$8185acef96710cad$export$8f903ef488e4ee0f","updatePattern","currentBoard","currentlyLitLightRow","lightData","$c1f9aa21b345dcac$export$8dceea515d6747fc","firstRun","currentlyLit","$4d5ca11e6b9118b1$export$da9194b27e270081","snakeHeadElm","snakeHead","curLight","snakeLength","window","addEventListener","document","getElementById","event","changeMode","setInterval","updateDisplay","chessBoard","buildBoard","mode","curTileElm","onOrOffTile","className","style","displayText","innerHTML","target","value","firstChild","removeChild","map","tileRow","cells","tileDiv","createElement","wasOn","validMove","rowDiv","cell","appendChild","boardRowDOMElm"],"version":3,"file":"index.03a69dd8.js.map"}