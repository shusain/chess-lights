{"mappings":"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","sources":["src/ChessPieces/ChessPiece.ts","src/ChessPieces/Bishop.ts","src/ChessTile.ts","src/ChessPieces/Knight.ts","src/ChessPieces/Pawn.ts","src/ChessPieces/Rook.ts","src/ChessPieces/Queen.ts","src/ChessPieces/King.ts","src/ChessBoard.ts","src/RowPattern.ts","src/SequencePattern.ts","src/SnakePattern.ts","src/ChessLightsMain.ts"],"sourcesContent":["import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\n\nexport abstract class ChessPiece {\n  abstract type() : string\n\n  constructor(public currentTile:ChessTile = null, public color: \"white\" | \"black\" = \"white\") {}\n\n  abstract findValidMoves(boardState : ChessBoard) : Array<{ x: number; y: number; }>\n  \n  getDirection = () => this.color === \"white\" ? 1 : -1\n\n  getPosition = () => ({\n    x: this.currentTile.x,\n    y: this.currentTile.y\n  })\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Bishop extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♝\" : \"♗\";\n  \n  hasMoved:boolean;\n\n  direction:boolean; // if true moving up the board if false moving down the board\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{xPosition:number, yPosition:number}> = []\n    throw new Error(\"Method not implemented.\");\n  }\n}","import { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessTile {\n    id: number\n    y: number\n    x: number\n    \n    isValidPosition: boolean\n\n    prevLight: ChessTile;\n    nextLight: ChessTile;\n\n    currentPiece:ChessPiece|null;\n\n    get tileBaseColor () {\n        return (this.id+(this.y%2))%2==0 ? \"green\" : \"blue\"\n    }\n\n    constructor(id, x, y, public isOn=false, public hue=0, public saturation=100, public brightness=50) {\n        this.id = id\n        this.x = x\n        this.y = y\n    }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Knight extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♞\" : \"♘\";\n  \n  hasMoved:boolean;\n\n  direction:boolean; // if true moving up the board if false moving down the board\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{xPosition:number, yPosition:number}> = []\n    throw new Error(\"Method not implemented.\");\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Pawn extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♟︎\" : \"♙\";\n  \n  public hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    let myPos = {\n      x: this.currentTile.x,\n      y: this.currentTile.y\n    }\n\n    let direction = this.color == \"white\" ? 1 : -1\n\n    let tileTL = boardState.getTileAtPosition(myPos.x+this.getDirection(), myPos.y+this.getDirection())\n    let tileTR = boardState.getTileAtPosition(myPos.x-this.getDirection(), myPos.y+this.getDirection())\n    \n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (tile.currentPiece && tile.currentPiece.color!=this.color)) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileTL,tileTR].forEach(tile=>addTilePositionIfValid(tile))\n\n    let pieceOneAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction)\n    if(!pieceOneAhead) {\n      validPositions.push({\n        x: myPos.x,\n        y: myPos.y+direction\n      })\n    }\n\n    // Pawn can move two spots if hasn't moved yet\n    if(!this.hasMoved) {\n      let twoPiecesAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction*2)\n      if(!twoPiecesAhead) {\n        validPositions.push({\n          x: myPos.x,\n          y: myPos.y+direction*2\n        })\n      }\n    }\n\n    return validPositions;\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Rook extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♜\" : \"♖\";\n  \n  hasMoved:boolean;\n\n  direction:boolean; // if true moving up the board if false moving down the board\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{xPosition:number, yPosition:number}> = []\n\n    throw new Error(\"Method not implemented.\");\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Queen extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♛\" : \"♕\";\n  \n  hasMoved:boolean;\n\n  direction:boolean; // if true moving up the board if false moving down the board\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{xPosition:number, yPosition:number}> = []\n    throw new Error(\"Method not implemented.\");\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class King extends ChessPiece {\n  type = () => this.color==\"black\" ?  \"♚\" : \"♔\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n\n    const myPos = this.getPosition();\n\n    let tileOneAbove = boardState.getTileAtPosition(myPos.x, myPos.y+this.getDirection())\n    let tileOneBelow = boardState.getTileAtPosition(myPos.x, myPos.y-this.getDirection())\n    let tileOneLeft = boardState.getTileAtPosition(myPos.x-1, myPos.y)\n    let tileOneRight = boardState.getTileAtPosition(myPos.x+1, myPos.y)\n    let tileTL = boardState.getTileAtPosition(myPos.x+this.getDirection(), myPos.y+this.getDirection())\n    let tileBL = boardState.getTileAtPosition(myPos.x+this.getDirection(), myPos.y-this.getDirection())\n    let tileTR = boardState.getTileAtPosition(myPos.x-this.getDirection(), myPos.y+this.getDirection())\n    let tileBR = boardState.getTileAtPosition(myPos.x-this.getDirection(), myPos.y-this.getDirection())\n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (!tile.currentPiece || (tile.currentPiece && tile.currentPiece.color!=this.color))) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileOneAbove, tileOneBelow, tileOneLeft, tileOneRight, tileTL, tileBL, tileTR, tileBR].forEach(tile => {\n      addTilePositionIfValid(tile)\n    })\n    \n    return validPositions\n  }\n}","import Bishop from \"./ChessPieces/Bishop\";\nimport { ChessTile } from \"./ChessTile\"\nimport Knight from \"./ChessPieces/Knight\";\nimport Pawn from \"./ChessPieces/Pawn\";\nimport Rook from \"./ChessPieces/Rook\";\nimport Queen from \"./ChessPieces/Queen\";\nimport King from \"./ChessPieces/King\";\nimport { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessBoard {\n    boardTiles: Array<Array<ChessTile>> = []\n    flatTileList:Array<ChessTile> = []\n\n    counter = 0\n    currentPlayersTurn: \"white\" | \"black\" = \"white\"\n    selectedPiece : ChessPiece\n\n    getTileAtPosition(x:number, y:number): ChessTile|null {\n        try {\n            return this.boardTiles[y][x];\n        } catch(e) {\n            return null\n        }\n    }\n\n    selectPiece(x:number, y:number): ChessPiece|null {\n        // Don't return a piece if a tile has a piece, but the piece isn't the same color as the current player\n        this.selectedPiece = this.getPieceAtPosition(x,y)\n        console.log(this.selectedPiece)\n        return this.selectedPiece\n    }\n    \n    getPieceAtPosition(x:number, y:number): ChessPiece|null {\n        try {\n            return this.boardTiles[y][x].currentPiece\n        } catch(e){\n            return null\n        }\n    }\n\n    movePiece(fromTile:ChessTile, toTile:ChessTile):void {\n        console.log('moving piece',fromTile, toTile)\n\n        toTile.currentPiece = fromTile.currentPiece\n        \n        if(toTile.currentPiece instanceof Pawn) {\n            toTile.currentPiece.hasMoved = true\n        }\n\n        fromTile.currentPiece = null\n        toTile.currentPiece.currentTile = toTile\n    }\n\n    setupDataModel() {\n        for (let y = 0; y < 8; y++) {\n            this.makeRow(y)\n        }\n\n        // setup link list references between objects\n        let prevLight\n        for (let i = 0; i < this.flatTileList.length; i++) {\n            const currentLight = this.flatTileList[i];\n            currentLight.prevLight = prevLight\n            if(i < this.flatTileList.length - 1) {\n                currentLight.nextLight = this.flatTileList[i+1]\n            }\n        }\n\n        this.flatTileList[0].prevLight = this.flatTileList[this.flatTileList.length - 1]\n        this.flatTileList[this.flatTileList.length - 1].nextLight = this.flatTileList[0]\n    }\n\n    setupPiecesOnBoard() {\n        // White back row\n        this.boardTiles[0][0].currentPiece = new Rook(this.boardTiles[0][0])\n        this.boardTiles[0][7].currentPiece = new Rook(this.boardTiles[0][7])\n\n        this.boardTiles[0][1].currentPiece = new Knight(this.boardTiles[0][1])\n        this.boardTiles[0][6].currentPiece = new Knight(this.boardTiles[0][6])\n\n        this.boardTiles[0][2].currentPiece = new Bishop(this.boardTiles[0][2])\n        this.boardTiles[0][5].currentPiece = new Bishop(this.boardTiles[0][5])\n\n        this.boardTiles[0][3].currentPiece = new Queen(this.boardTiles[0][3])\n        this.boardTiles[0][4].currentPiece = new King(this.boardTiles[0][4])\n\n        \n        // Black back row\n        this.boardTiles[7][0].currentPiece = new Rook(this.boardTiles[7][0], \"black\")\n        this.boardTiles[7][7].currentPiece = new Rook(this.boardTiles[7][7], \"black\")\n\n        this.boardTiles[7][1].currentPiece = new Knight(this.boardTiles[7][1], \"black\")\n        this.boardTiles[7][6].currentPiece = new Knight(this.boardTiles[7][6], \"black\")\n\n        this.boardTiles[7][2].currentPiece = new Bishop(this.boardTiles[7][2], \"black\")\n        this.boardTiles[7][5].currentPiece = new Bishop(this.boardTiles[7][5], \"black\")\n\n        this.boardTiles[7][3].currentPiece = new King(this.boardTiles[7][3], \"black\")\n        this.boardTiles[7][4].currentPiece = new Queen(this.boardTiles[7][4], \"black\")\n\n        for(let x=0; x < 8; x++) {\n            // White pawns\n            this.boardTiles[1][x].currentPiece = new Pawn(this.boardTiles[1][x])\n\n            // Black pawns\n            this.boardTiles[6][x].currentPiece = new Pawn(this.boardTiles[6][x], \"black\")\n        }\n    }\n    \n    /**\n     * return Array of currently lit positions\n     */\n    findCurrentlyLit() {\n        return this.flatTileList.filter(element => element.isOn )\n    }\n\n    turnOffAll() {\n        this.flatTileList.forEach(light => light.isOn = false)\n    }\n\n    markAllInvalid() {\n        this.flatTileList.forEach(light => light.isValidPosition = false)\n    }\n\n    makeRow(rowNum: number) {\n        this.boardTiles[rowNum] = []\n\n        for (let x = 0; x < 8; x++) {\n            const newLightObject = new ChessTile(this.counter++, x, rowNum)\n\n            this.boardTiles[rowNum].push(newLightObject)\n\n            this.flatTileList.push(newLightObject)\n        }\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class RowPattern implements ILightPattern {\n    currentlyLitLightRow = 0\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        currentBoard.boardTiles[this.currentlyLitLightRow].forEach(lightData => lightData.isOn = true)\n        this.currentlyLitLightRow++\n        if(this.currentlyLitLightRow >= currentBoard.boardTiles.length) {\n            this.currentlyLitLightRow = 0\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SequencePattern implements ILightPattern {\n    firstRun = true\n    constructor() {\n    }\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        if(this.firstRun) {\n            currentBoard.turnOffAll()\n            currentBoard.flatTileList[0].isOn = true\n            this.firstRun = false\n        }\n        let currentlyLit = currentBoard.findCurrentlyLit()\n        \n        if(currentlyLit.length > 0) {\n\n            for (let i = currentlyLit.length - 1; 0 <= i; i--) {\n                const lightData = currentlyLit[i];\n                \n                lightData.isOn = false;\n                lightData.nextLight.isOn = true;\n            }\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SnakePattern implements ILightPattern {\n    snakeHead = 0\n    snakeLength = 12\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        let snakeHeadElm = currentBoard.flatTileList[this.snakeHead]\n        snakeHeadElm.isOn = true\n\n        let curLight = snakeHeadElm\n        for (let i = 0; i < this.snakeLength; i++) {\n            curLight = curLight.nextLight\n            curLight.isOn = true\n            if(i==0)\n                this.snakeHead = curLight.id\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\"\nimport { ILightPattern } from \"./ILightPattern\"\nimport { RowPattern } from \"./RowPattern\"\nimport { SequencePattern } from \"./SequencePattern\"\nimport { SnakePattern } from \"./SnakePattern\"\n\nexport class ChessLightsMain {\n    chessBoard:ChessBoard\n    mode: ILightPattern\n\n    constructor() {\n        // Waiting for page to be loaded to get the elemnets on the page and add listeners/setup the game\n        window.addEventListener('DOMContentLoaded', () => {\n\n            // Listener for the drop down menu\n            document.getElementById('mode').addEventListener('change', (event) => {\n                this.changeMode(event)\n            })\n\n            setInterval(() => {\n                this.updateDisplay()\n            }, 100)\n\n            this.chessBoard = new ChessBoard()\n            this.chessBoard.setupDataModel()\n            this.chessBoard.setupPiecesOnBoard()\n            this.buildBoard()\n            // this.mode = new SequencePattern()\n        });\n    }\n\n    /**\n     * Called on an interval to update the DOM elements that represent the board visually based on the board model\n     */\n    updateDisplay() {\n        if(this.mode) {\n            this.chessBoard = this.mode.updatePattern(this.chessBoard)\n        }\n\n        this.chessBoard.flatTileList.forEach(tile => {\n\n            let curTileElm = document.getElementById(`tile-${tile.id}`)\n            const evenOrOddTile = (tile.id+1) % 2 == 0 ? 'even':'odd'\n            const onOrOffTile = tile.isOn ? 'on':'off'\n            curTileElm.className = `chess-tile ${onOrOffTile} ${evenOrOddTile}`\n            if(tile.isOn) {\n                curTileElm.style.backgroundColor = `hsl(${tile.hue}, ${tile.saturation}%, ${tile.brightness}%)`\n            } else {\n                curTileElm.style.backgroundColor = tile.tileBaseColor\n            }\n            \n            if(tile.currentPiece) {\n                curTileElm.style.color = tile.currentPiece.color\n            }\n\n            let displayText = \"\"\n            if(tile.currentPiece) {\n                displayText = tile.currentPiece.type()\n            }\n\n            curTileElm.innerHTML = `${displayText}`\n        })\n    }\n\n    /**\n     * Method handles drop down change events and creates the corresponding light pattern/sequence handler.  Used primarily for prototyping LED patterns for LED chess board.\n     * \n     * @param event an event from the select/options dropdown, the event.target.value is used to determine which Pattern instance to create\n     */\n    changeMode(event) {\n        switch(event.target.value) {\n            case 'snake': this.mode = new SnakePattern()\n            break;\n            case 'sequence': this.mode = new SequencePattern()\n            break;\n            case 'row': this.mode = new RowPattern()\n            break;\n            case 'none': this.mode = null\n            break;\n        }\n    }\n\n    /**\n     * Clears out and rebuilds the DOM elements for the board based on the board model\n     * deals with finding valid moves and highlighting cells on the board based on the\n     * board model\n     */\n    buildBoard() {\n        let chessBoard = document.getElementById('chess-board')\n        \n        while (chessBoard.firstChild) {\n            chessBoard.removeChild(chessBoard.firstChild);\n        }\n\n        // Maps all the tiles row by row into DOM elements\n        const boardRowDOMElms = this.chessBoard.boardTiles\n            .map((tileRow) => {\n\n                // Maps all the cells of a given row into DOM elements\n                const cells = tileRow.map((tile) => {\n                    let tileDiv = document.createElement('div')\n                    tileDiv.className = `chess-tile ${tile.id % 2 == 0 ? 'even':'odd'}  ${tile.isOn ? 'on':'off'}`\n                    tileDiv.id=`tile-${tile.id}`\n\n                    let tileClickHandler = () => {\n                        if(tile.isValidPosition) {\n                            this.chessBoard.movePiece(this.chessBoard.selectedPiece.currentTile, tile)\n                            this.chessBoard.turnOffAll();\n                            this.chessBoard.markAllInvalid();\n                            this.chessBoard.currentPlayersTurn = this.chessBoard.currentPlayersTurn === \"white\" ? \"black\" : \"white\";\n                        }\n                        else {\n                            let selectedPiece = this.chessBoard.selectPiece(tile.x, tile.y)\n                            let wasOn = tile.isOn;\n                            \n                            this.chessBoard.turnOffAll();\n                            \n                            if(selectedPiece) {\n                                tile.isOn = !wasOn\n                                if(tile.isOn) {\n                                    this.chessBoard.markAllInvalid();\n                                    let validMoves = selectedPiece.findValidMoves(this.chessBoard)\n    \n                                    validMoves.forEach(validMove => {\n                                        // Marking all the valid moves for the selected piece on the board\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isValidPosition = true\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isOn = true\n                                    })\n                                }\n                            }\n                        }\n                    }\n\n                    tileDiv.addEventListener('click', tileClickHandler)\n                    return tileDiv\n                })\n                let rowDiv = document.createElement('div')\n                rowDiv.className = 'row'\n                cells.forEach(cell => {rowDiv.appendChild(cell)})\n                return rowDiv\n            })\n        boardRowDOMElms.forEach(boardRowDOMElm => chessBoard.appendChild(boardRowDOMElm))\n        \n    }\n}\nnew ChessLightsMain()"],"names":["$b22d20f8eed3c195$export$57e01e9070034a96","currentTile","color","this","getDirection","getPosition","x","y","$0d26fdf8bf377e35$export$2e2bcd8739ae039","findValidMoves","boardState","Error","type","$19302002edd8d79c$export$a9149a6cae1863c8","tileBaseColor","id","isOn","hue","saturation","brightness","$4f1600a5f2f06aab$export$2e2bcd8739ae039","$f1ffc8d94fc3f9eb$export$2e2bcd8739ae039","validPositions","myPos","direction","tileTL","getTileAtPosition","tileTR","addTilePositionIfValid","tile","currentPiece","push","forEach","getPieceAtPosition","hasMoved","$c374f64110df5620$export$2e2bcd8739ae039","$1ef2ac3924524536$export$2e2bcd8739ae039","$6364cc4a6fd49207$export$2e2bcd8739ae039","tileOneAbove","tileOneBelow","tileOneLeft","tileOneRight","tileBL","tileBR","$b07460e442fde56f$export$e27bc415f35efa4e","boardTiles","e","selectPiece","selectedPiece","console","log","movePiece","fromTile","toTile","setupDataModel","makeRow","i","flatTileList","length","currentLight","prevLight","nextLight","setupPiecesOnBoard","findCurrentlyLit","filter","element","turnOffAll","light","markAllInvalid","isValidPosition","rowNum","newLightObject","counter","currentPlayersTurn","$8185acef96710cad$export$8f903ef488e4ee0f","updatePattern","currentBoard","currentlyLitLightRow","lightData","$c1f9aa21b345dcac$export$8dceea515d6747fc","firstRun","currentlyLit","$4d5ca11e6b9118b1$export$da9194b27e270081","snakeHeadElm","snakeHead","curLight","snakeLength","window","addEventListener","document","getElementById","event","changeMode","setInterval","updateDisplay","chessBoard","buildBoard","mode","curTileElm","evenOrOddTile","onOrOffTile","className","style","backgroundColor","displayText","innerHTML","target","value","firstChild","removeChild","map","tileRow","cells","tileDiv","createElement","wasOn","validMove","rowDiv","cell","appendChild","boardRowDOMElm"],"version":3,"file":"index.7863f23c.js.map"}