{"mappings":"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","sources":["src/ChessPieces/ChessPiece.ts","src/ChessPieces/Bishop.ts","src/ChessTile.ts","src/ChessPieces/Knight.ts","src/ChessPieces/Pawn.ts","src/ChessPieces/Rook.ts","src/ChessPieces/Queen.ts","src/ChessPieces/King.ts","src/Player.ts","src/ChessBoard.ts","src/RowPattern.ts","src/SequencePattern.ts","src/SnakePattern.ts","src/ChessLightsMain.ts"],"sourcesContent":["import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\n\n/**\n * Abstract Base Class for common properties/methods for all of the pieces\n */\nexport default abstract class ChessPiece {\n  abstract pieceSymbol(): string\n  /**\n   * \n   * @param boardState The current board state to find valid moves on\n   */\n  abstract findValidMoves(boardState: ChessBoard): Array<{ x: number; y: number; }>\n  abstract clone(boardTiles:Array<Array<ChessTile>>): ChessPiece\n  public currentTile: ChessTile = null\n\n  constructor(boardTiles: Array<Array<ChessTile>>, x: number, y: number, public color: \"white\" | \"black\" = \"white\") {\n    boardTiles[x][y].currentPiece = this\n    this.currentTile = boardTiles[x][y]\n  }\n\n  get direction() { return this.color === \"white\" ? 1 : -1 }\n\n  get myPos() {\n    return {\n      x: this.currentTile.x,\n      y: this.currentTile.y\n    }\n  }\n\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Bishop extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♝\" : \"♗\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Bishop(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessPiece from \"./ChessPieces/ChessPiece\";\n\nexport default class ChessTile {\n    id: number\n    y: number\n    x: number\n    \n    isValidPosition: boolean\n\n    prevLight: ChessTile;\n    nextLight: ChessTile;\n\n    currentPiece:ChessPiece|null;\n\n    get tileBaseColor () {\n        return (this.id+(this.y%2))%2==0 ? \"black\" : \"white\"\n    }\n\n    constructor(id, x, y, public isOn=false, public hue=0, public saturation=100, public brightness=50) {\n        this.id = id\n        this.x = x\n        this.y = y\n    }\n\n    // Just clones the object with properties needed for checking valid positions\n    // for checking hypothetical board states\n    clone() {\n        return new ChessTile(this.id, this.x, this.y)\n    }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Knight extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♞\" : \"♘\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n    \n    let tileOne = boardState.getTileAtPosition(myPos.x+2, myPos.y+1)\n    let tileTwo = boardState.getTileAtPosition(myPos.x+1, myPos.y+2)\n    let tileThree = boardState.getTileAtPosition(myPos.x-2, myPos.y+1)\n    let tileFour = boardState.getTileAtPosition(myPos.x-1, myPos.y+2)\n    \n    let tileFive = boardState.getTileAtPosition(myPos.x-2, myPos.y-1)\n    let tileSix = boardState.getTileAtPosition(myPos.x-1, myPos.y-2)\n    let tileSeven = boardState.getTileAtPosition(myPos.x+2, myPos.y-1)\n    let tileEight = boardState.getTileAtPosition(myPos.x+1, myPos.y-2);\n\n    [tileOne,tileTwo,tileThree,tileFour,tileFive,tileSix,tileSeven,tileEight].forEach(tile=>{\n      // skip if the tile doesn't exist\n      if(!tile) return;\n      // \n      if(!tile.currentPiece || tile.currentPiece.color != this.color) {\n        validPositions.push(tile)\n      }\n    })\n\n\n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Knight(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Pawn extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♟︎\" : \"♙\";\n  \n  public hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos, direction} = this\n\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    \n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (tile.currentPiece && tile.currentPiece.color!=this.color)) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileTL,tileTR].forEach(tile=>addTilePositionIfValid(tile))\n\n    let pieceOneAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction)\n    if(!pieceOneAhead) {\n      validPositions.push({\n        x: myPos.x,\n        y: myPos.y+direction\n      })\n    }\n\n    // Pawn can move two spots if hasn't moved yet\n    if(!this.hasMoved && !pieceOneAhead) {\n      let twoPiecesAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction*2)\n      if(!twoPiecesAhead) {\n        validPositions.push({\n          x: myPos.x,\n          y: myPos.y+direction*2\n        })\n      }\n    }\n\n    return validPositions;\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Pawn(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Rook extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♜\" : \"♖\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    // Destructuring props of this\n    const {myPos} = this\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Rook(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Queen extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♛\" : \"♕\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this;\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Queen(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class King extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♚\" : \"♔\";\n  \n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n\n    const {myPos, direction} = this;\n\n    // Cardinal positions\n    let tileOneAbove = boardState.getTileAtPosition(myPos.x, myPos.y+direction)\n    let tileOneBelow = boardState.getTileAtPosition(myPos.x, myPos.y-direction)\n    let tileOneLeft = boardState.getTileAtPosition(myPos.x-1, myPos.y)\n    let tileOneRight = boardState.getTileAtPosition(myPos.x+1, myPos.y)\n\n    // Diaganol moves\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileBL = boardState.getTileAtPosition(myPos.x+direction, myPos.y-direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    let tileBR = boardState.getTileAtPosition(myPos.x-direction, myPos.y-direction)\n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (!tile.currentPiece || (tile.currentPiece && tile.currentPiece.color!=this.color))) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileOneAbove, tileOneBelow, tileOneLeft, tileOneRight, tileTL, tileBL, tileTR, tileBR].forEach(tile => {\n      addTilePositionIfValid(tile)\n    })\n    \n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new King(boardTiles, this.currentTile.x, this.currentTile.y)\n  }\n}","import ChessPiece from \"./ChessPieces/ChessPiece\";\nimport King from \"./ChessPieces/King\";\n\nexport default class Player {\n  pieces: Array<ChessPiece>\n  constructor(public color: \"white\" | \"black\") { }\n  get king() {\n    return this.pieces.find((value,index,obj) => {\n      return value instanceof King\n    })\n  }\n}","import Bishop from \"./ChessPieces/Bishop\";\nimport ChessTile from \"./ChessTile\"\nimport Knight from \"./ChessPieces/Knight\";\nimport Pawn from \"./ChessPieces/Pawn\";\nimport Rook from \"./ChessPieces/Rook\";\nimport Queen from \"./ChessPieces/Queen\";\nimport King from \"./ChessPieces/King\";\nimport ChessPiece from \"./ChessPieces/ChessPiece\";\nimport Player from \"./Player\";\n\n/**\n * Builds the board and keeps track of the game state (selected piece, current player etc)\n * \n * The board is an x/y grid drawn top to bottom left to right\n */\nexport default class ChessBoard {\n  redraw: boolean = true\n  boardTiles: Array<Array<ChessTile>> = []\n  flatTileList: Array<ChessTile> = []\n  players: Array<Player> = []\n\n  counter = 0\n\n  selectedPiece: ChessPiece\n  get currentPlayersTurn(): \"white\" | \"black\" {\n    return this.currentPlayer.color\n  }\n  currentPlayer: Player\n  get whitePlayer() {\n    return this.players[0]\n  }\n  get blackPlayer() {\n    return this.players[1]\n  }\n\n  constructor() {\n    this.setupDataModel()\n    this.setupPiecesOnBoard()\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for tile to get (0-7)\n   * @param y Vetical offset from 0 for tile to get (0-7)\n   * @returns A ChessTile if one exists at the position or null if the position is out of bounds\n   */\n  getTileAtPosition(x: number, y: number): ChessTile | null {\n    try {\n      return this.boardTiles[y][x];\n    } catch (e) {\n      return null\n    }\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for Piece to get (0-7)\n   * @param y Vertical offset from 0 for Piece to get (0-7)\n   * @returns Piece on tile at given position or null if no piece or invalid tile\n   */\n  getPieceAtPosition(x: number, y: number): ChessPiece | null {\n    try {\n      return this.boardTiles[y][x].currentPiece\n    } catch (e) {\n      return null\n    }\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for Piece to select (0-7)\n   * @param y Vertical offset from 0 for Piece to select (0-7)\n   * @returns The selected piece if a piece existed on the tile at the given position or null if no piece or tile at position\n   */\n  selectPiece(x: number, y: number): ChessPiece | null {\n    // Don't return a piece if a tile has a piece, but the piece isn't the same color as the current player\n    this.selectedPiece = this.getPieceAtPosition(x, y)\n    console.log(this.selectedPiece)\n    return this.selectedPiece\n  }\n\n  /**\n   * Method will move a piece from one tile to another so long as the move\n   * doesn't put or leave the current player's king in check.\n   * \n   * @param fromTile The tile to move the piece from\n   * @param toTile The tile to move the piece to\n   * @returns [boolean] true if the piece was moved false if it was not\n   */\n  movePiece(fromTile: ChessTile, toTile: ChessTile): boolean {\n    console.log('moving piece', fromTile, toTile)\n\n    toTile.currentPiece = fromTile.currentPiece\n\n    if (toTile.currentPiece instanceof Pawn) {\n      toTile.currentPiece.hasMoved = true\n    }\n\n    fromTile.currentPiece = null\n    toTile.currentPiece.currentTile = toTile\n\n    return true\n  }\n\n  /**\n   * return Array of currently lit positions\n   */\n  findCurrentlyLit() {\n    return this.flatTileList.filter(element => element.isOn)\n  }\n\n  /**\n   * Sets the isOn property to false for all tiles\n   */\n  turnOffAllTileLights() {\n    this.flatTileList.forEach(light => light.isOn = false)\n  }\n\n  /**\n   * Sets the isValidPosition to false for all tiles\n   */\n  markAllInvalid() {\n    this.flatTileList.forEach(light => light.isValidPosition = false)\n  }\n\n  /**\n   * Sets up the initial data model(s) for the tiles, creates all the rows\n   * that make up the grid of tiles and populates each row with tiles\n   */\n  setupDataModel() {\n    for (let y = 0; y < 8; y++) {\n      this.makeRow(y)\n    }\n\n    // setup link list references between objects\n    let prevLight\n    for (let i = 0; i < this.flatTileList.length; i++) {\n      const currentLight = this.flatTileList[i];\n      currentLight.prevLight = prevLight\n      if (i < this.flatTileList.length - 1) {\n        currentLight.nextLight = this.flatTileList[i + 1]\n      }\n    }\n\n    this.flatTileList[0].prevLight = this.flatTileList[this.flatTileList.length - 1]\n    this.flatTileList[this.flatTileList.length - 1].nextLight = this.flatTileList[0]\n  }\n\n  setupPiecesOnBoard() {\n    // White back row\n    let whiteRook1 = new Rook(this.boardTiles, 0, 0)\n    let whiteRook2 = new Rook(this.boardTiles, 0, 7)\n\n    let whiteKnight1 = new Knight(this.boardTiles, 0, 1)\n    let whiteKnight2 = new Knight(this.boardTiles, 0, 6)\n\n    let whiteBishop1 = new Bishop(this.boardTiles, 0, 2)\n    let whiteBishop2 = new Bishop(this.boardTiles, 0, 5)\n\n    let whiteQueen = new Queen(this.boardTiles, 0, 3)\n    let whiteKing = new King(this.boardTiles, 0, 4)\n\n    // Black back row\n    let blackRook1 = new Rook(this.boardTiles, 7, 0, \"black\")\n    let blackRook2 = new Rook(this.boardTiles, 7, 7, \"black\")\n\n    let blackKnight1 = new Knight(this.boardTiles, 7, 1, \"black\")\n    let blackKnight2 = new Knight(this.boardTiles, 7, 6, \"black\")\n\n    let blackBishop1 = new Bishop(this.boardTiles, 7, 2, \"black\")\n    let blackBishop2 = new Bishop(this.boardTiles, 7, 5, \"black\")\n\n    let blackQueen = new Queen(this.boardTiles, 7, 3, \"black\")\n    let blackKing = new King(this.boardTiles, 7, 4, \"black\")\n\n    const whitePawns = []\n    const blackPawns = []\n\n    for (let x = 0; x < 8; x++) {\n      // White pawns\n      const whitePawn = new Pawn(this.boardTiles, 1, x)\n      whitePawns.push(whitePawn)\n\n      // Black pawns\n      const blackPawn = new Pawn(this.boardTiles, 6, x, \"black\")\n      blackPawns.push(blackPawn)\n    }\n\n    const player1 = new Player(\"white\")\n    player1.pieces = [whiteRook1, whiteRook2, whiteKnight1, whiteKnight2, whiteBishop1, whiteBishop2, whiteQueen, whiteKing, ...whitePawns]\n\n    const player2 = new Player(\"black\")\n    player2.pieces = [blackRook1, blackRook2, blackKnight1, blackKnight2, blackBishop1, blackBishop2, blackQueen, blackKing, ...blackPawns]\n\n    this.players = [player1, player2]\n\n    this.currentPlayer = player1\n  }\n\n  changeCurrentPlayer() {\n    this.currentPlayer = this.currentPlayer === this.players[0] ? this.players[1] : this.players[0];\n  }\n\n  makeRow(rowNum: number) {\n    this.boardTiles[rowNum] = []\n\n    for (let x = 0; x < 8; x++) {\n      const newLightObject = new ChessTile(this.counter++, x, rowNum)\n\n      this.boardTiles[rowNum].push(newLightObject)\n\n      this.flatTileList.push(newLightObject)\n    }\n  }\n\n  checkIfCurrentPlayerIsInCheck() {\n    this.checkIfPlayerIsInCheck(this.currentPlayer)\n  }\n\n  checkIfPlayerIsInCheck(targetPlayer:Player) {\n    const otherPlayer = this.whitePlayer == targetPlayer ? this.blackPlayer : this.whitePlayer\n\n    otherPlayer.pieces.forEach(piece => {\n      const validMoves = piece.findValidMoves(this)\n      // If king is in check\n      if(targetPlayer.king && validMoves.find(val => val.x == targetPlayer.king.currentTile.x && val.y == targetPlayer.king.currentTile.y) ) {\n        alert(\"king in check\")\n      }\n    })\n  }\n\n  /**\n   * Will see if moving any of the target player's pieces will result in the\n   * player no longer being in check\n   * \n   * @param targetPlayer The player to see if cannot make a move to get out of\n   * check mate\n   */\n  checkIfPlayerIsInCheckmate(targetPlayer:Player) {\n    const otherPlayer = this.whitePlayer == targetPlayer ? this.blackPlayer : this.whitePlayer\n\n    let currentBoardState = this.clone()\n    otherPlayer.pieces.forEach(piece => {\n      const validMoves = piece.findValidMoves(this)\n      // If king is in check\n      if(targetPlayer.king && validMoves.find(val => val.x == targetPlayer.king.currentTile.x && val.y == targetPlayer.king.currentTile.y) ) {\n        alert(\"king in check\")\n      }\n    })\n  }\n\n  clone() {\n    let clonedBoard = new ChessBoard()\n\n    // Just copying the players since we only need them for reference of their pieces\n    // and won't be changing the players pieces when checking board states\n    clonedBoard.players = this.players\n\n    return clonedBoard\n  }\n\n  tileClickHandler(tile: ChessTile) {\n    if (tile.isValidPosition) {\n      this.movePiece(this.selectedPiece.currentTile, tile)\n      this.turnOffAllTileLights();\n      this.markAllInvalid();\n      this.changeCurrentPlayer();\n      this.checkIfCurrentPlayerIsInCheck();\n    }\n    else {\n      this.markAllInvalid();\n      let selectedPiece = this.selectPiece(tile.x, tile.y)\n      let wasOn = tile.isOn;\n      this.turnOffAllTileLights();\n\n      if (selectedPiece && selectedPiece.color == this.currentPlayersTurn) {\n        tile.isOn = !wasOn\n        if (tile.isOn) {\n          let validMoves = selectedPiece.findValidMoves(this)\n\n          validMoves.forEach(validMove => {\n            // Marking all the valid moves for the selected piece on the board\n            this.getTileAtPosition(validMove.x, validMove.y).isValidPosition = true\n            this.getTileAtPosition(validMove.x, validMove.y).isOn = true\n          })\n        }\n      }\n    }\n\n    this.redraw = true\n\n  }\n}","import ChessBoard from \"./ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class RowPattern implements ILightPattern {\n    currentlyLitLightRow = 0\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAllTileLights()\n\n        currentBoard.boardTiles[this.currentlyLitLightRow].forEach(lightData => lightData.isOn = true)\n        this.currentlyLitLightRow++\n        if(this.currentlyLitLightRow >= currentBoard.boardTiles.length) {\n            this.currentlyLitLightRow = 0\n        }\n        return currentBoard\n    }\n}","import ChessBoard from \"./ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class SequencePattern implements ILightPattern {\n    firstRun = true\n    constructor() {\n    }\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        if(this.firstRun) {\n            currentBoard.turnOffAllTileLights()\n            currentBoard.flatTileList[0].isOn = true\n            this.firstRun = false\n        }\n        let currentlyLit = currentBoard.findCurrentlyLit()\n        \n        if(currentlyLit.length > 0) {\n\n            for (let i = currentlyLit.length - 1; 0 <= i; i--) {\n                const lightData = currentlyLit[i];\n                \n                lightData.isOn = false;\n                lightData.nextLight.isOn = true;\n            }\n        }\n        return currentBoard\n    }\n}","import ChessBoard from \"./ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class SnakePattern implements ILightPattern {\n    snakeHead = 0\n    snakeLength = 12\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAllTileLights()\n\n        let snakeHeadElm = currentBoard.flatTileList[this.snakeHead]\n        snakeHeadElm.isOn = true\n\n        let curLight = snakeHeadElm\n        for (let i = 0; i < this.snakeLength; i++) {\n            curLight = curLight.nextLight\n            curLight.isOn = true\n            if(i==0)\n                this.snakeHead = curLight.id\n        }\n        return currentBoard\n    }\n}","import ChessBoard from \"./ChessBoard\"\nimport ILightPattern from \"./ILightPattern\"\nimport { RowPattern } from \"./RowPattern\"\nimport { SequencePattern } from \"./SequencePattern\"\nimport { SnakePattern } from \"./SnakePattern\"\n\nexport class ChessLightsMain {\n  chessBoard: ChessBoard\n  mode: ILightPattern\n\n  constructor() {\n    // Waiting for page to be loaded to get the elements on the page and add\n    // listeners/setup the game\n    window.addEventListener('DOMContentLoaded', () => {\n\n      // Listener for the drop down menu\n      document.getElementById('mode').addEventListener('change', (event) => {\n        this.changeMode(event)\n      })\n\n      setInterval(() => {\n        this.updateDisplay()\n      }, 100)\n\n      this.chessBoard = new ChessBoard()\n      this.drawInitialBoard()\n      // this.mode = new SequencePattern()\n    });\n  }\n\n  /**\n   * Called on an interval to update the DOM elements that represent the board\n   * visually based on the board model\n   */\n  updateDisplay() {\n    // If using a lighting mode then update the tile light pattern on each loop\n    if (this.mode) {\n      this.chessBoard = this.mode.updatePattern(this.chessBoard)\n    }\n\n    // Update all the tile styles and contents\n    if(this.chessBoard.redraw) {\n      this.chessBoard.flatTileList.forEach(tile => {\n  \n        let curTileElm = document.getElementById(`tile-${tile.id}`)\n        const onOrOffTile = tile.isOn ? 'on' : 'off'\n  \n        const newClassName = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n        if(curTileElm.className != newClassName)\n        curTileElm.className = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n  \n        if (tile.currentPiece) {\n          curTileElm.style.color = tile.currentPiece.color\n        }\n  \n        let displayText = \"\"\n        if (tile.currentPiece) {\n          displayText = tile.currentPiece.pieceSymbol()\n        }\n  \n        curTileElm.innerHTML = `${displayText}`\n      })\n      this.chessBoard.redraw = false\n    }\n  }\n\n  /**\n   * Method handles drop down change events and creates the corresponding light\n   * pattern/sequence handler.  Used primarily for prototyping LED patterns for\n   * LED chess board.\n   * \n   * @param event an event from the select/options dropdown, the event.target.value is used to determine which Pattern instance to create\n   */\n  changeMode(event) {\n    switch (event.target.value) {\n      case 'snake': this.mode = new SnakePattern()\n        break;\n      case 'sequence': this.mode = new SequencePattern()\n        break;\n      case 'row': this.mode = new RowPattern()\n        break;\n      case 'none': this.mode = null\n        break;\n    }\n  }\n\n  /**\n   * Clears out and rebuilds the DOM elements for the board based on the board model\n   * deals with finding valid moves and highlighting cells on the board based on the\n   * board model\n   */\n  drawInitialBoard() {\n    let chessBoard = document.getElementById('chess-board')\n\n    while (chessBoard.firstChild) {\n      chessBoard.removeChild(chessBoard.firstChild);\n    }\n\n    // Maps all the tiles row by row into DOM elements\n    const boardRowDOMElms = this.chessBoard.boardTiles\n      .map((tileRow) => {\n\n        // Maps all the cells of a given row into DOM elements\n        const cells = tileRow.map((tile) => {\n          let tileDiv = document.createElement('div')\n          tileDiv.className = `chess-tile ${tile.id % 2 == 0 ? 'even' : 'odd'}  ${tile.isOn ? 'on' : 'off'} tile-color-${tile.tileBaseColor}`\n          tileDiv.id = `tile-${tile.id}`\n\n          tileDiv.addEventListener('click', () => { this.chessBoard.tileClickHandler(tile) })\n          return tileDiv\n        })\n        let rowDiv = document.createElement('div')\n        rowDiv.className = 'row'\n        cells.forEach(cell => { rowDiv.appendChild(cell) })\n        return rowDiv\n      })\n    boardRowDOMElms.forEach(boardRowDOMElm => chessBoard.appendChild(boardRowDOMElm))\n\n  }\n}\nnew ChessLightsMain()"],"names":["$b22d20f8eed3c195$export$2e2bcd8739ae039","boardTiles","x","y","color","this","currentTile","currentPiece","direction","myPos","$0d26fdf8bf377e35$export$2e2bcd8739ae039","findValidMoves","boardState","validPositions","i","j","curTile","getTileAtPosition","push","i1","j1","i2","j2","i3","j3","clone","pieceSymbol","$19302002edd8d79c$export$2e2bcd8739ae039","tileBaseColor","id","isOn","hue","saturation","brightness","$4f1600a5f2f06aab$export$2e2bcd8739ae039","forEach","tile","$f1ffc8d94fc3f9eb$export$2e2bcd8739ae039","tileTL","tileTR","addTilePositionIfValid","pieceOneAhead","getPieceAtPosition","hasMoved","$c374f64110df5620$export$2e2bcd8739ae039","$1ef2ac3924524536$export$2e2bcd8739ae039","i4","i5","i6","i7","$6364cc4a6fd49207$export$2e2bcd8739ae039","tileOneAbove","tileOneBelow","tileOneLeft","tileOneRight","tileBL","tileBR","$ac5fb69ba5837957$export$2e2bcd8739ae039","king","pieces","find","value","index","obj","$b07460e442fde56f$export$2e2bcd8739ae039","currentPlayersTurn","currentPlayer","whitePlayer","players","blackPlayer","redraw","flatTileList","counter","setupDataModel","setupPiecesOnBoard","e","selectPiece","selectedPiece","console","log","movePiece","fromTile","toTile","findCurrentlyLit","filter","element","turnOffAllTileLights","light","markAllInvalid","isValidPosition","makeRow","length","currentLight","prevLight","nextLight","whiteRook1","whiteRook2","whiteKnight1","whiteKnight2","whiteBishop1","whiteBishop2","whiteQueen","whiteKing","blackRook1","blackRook2","blackKnight1","blackKnight2","blackBishop1","blackBishop2","blackQueen","blackKing","whitePawns","blackPawns","whitePawn","blackPawn","player1","player2","changeCurrentPlayer","rowNum","newLightObject","checkIfCurrentPlayerIsInCheck","checkIfPlayerIsInCheck","targetPlayer","piece","validMoves","val","alert","checkIfPlayerIsInCheckmate","otherPlayer","clonedBoard","tileClickHandler","wasOn","validMove","$8185acef96710cad$export$8f903ef488e4ee0f","updatePattern","currentBoard","currentlyLitLightRow","lightData","$c1f9aa21b345dcac$export$8dceea515d6747fc","firstRun","currentlyLit","$4d5ca11e6b9118b1$export$da9194b27e270081","snakeHeadElm","snakeHead","curLight","snakeLength","window","addEventListener","document","getElementById","event","changeMode","setInterval","updateDisplay","chessBoard","drawInitialBoard","mode","curTileElm","onOrOffTile","newClassName","className","style","displayText","innerHTML","target","firstChild","removeChild","map","tileRow","cells","tileDiv","createElement","rowDiv","cell","appendChild","boardRowDOMElm"],"version":3,"file":"index.50aa212d.js.map"}