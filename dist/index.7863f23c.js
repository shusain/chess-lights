class e{constructor(e=null,t="white"){this.currentTile=e,this.color=t,this.getDirection=()=>"white"===this.color?1:-1,this.getPosition=()=>({x:this.currentTile.x,y:this.currentTile.y})}}class t extends e{findValidMoves(e){throw new Error("Method not implemented.")}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♝":"♗"}}class i{get tileBaseColor(){return(this.id+this.y%2)%2==0?"green":"blue"}constructor(e,t,i,s=!1,r=0,o=100,n=50){this.isOn=s,this.hue=r,this.saturation=o,this.brightness=n,this.id=e,this.x=t,this.y=i}}class s extends e{findValidMoves(e){throw new Error("Method not implemented.")}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♞":"♘"}}class r extends e{findValidMoves(e){const t=[];let i={x:this.currentTile.x,y:this.currentTile.y},s="white"==this.color?1:-1,r=e.getTileAtPosition(i.x+this.getDirection(),i.y+this.getDirection()),o=e.getTileAtPosition(i.x-this.getDirection(),i.y+this.getDirection());const n=e=>{e&&e.currentPiece&&e.currentPiece.color!=this.color&&t.push({x:e.x,y:e.y})};if([r,o].forEach((e=>n(e))),e.getPieceAtPosition(i.x,i.y+s)||t.push({x:i.x,y:i.y+s}),!this.hasMoved){e.getPieceAtPosition(i.x,i.y+2*s)||t.push({x:i.x,y:i.y+2*s})}return t}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♟︎":"♙"}}class o extends e{findValidMoves(e){throw new Error("Method not implemented.")}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♜":"♖"}}class n extends e{findValidMoves(e){throw new Error("Method not implemented.")}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♛":"♕"}}class l extends e{findValidMoves(e){const t=[],i=this.getPosition();let s=e.getTileAtPosition(i.x,i.y+this.getDirection()),r=e.getTileAtPosition(i.x,i.y-this.getDirection()),o=e.getTileAtPosition(i.x-1,i.y),n=e.getTileAtPosition(i.x+1,i.y),l=e.getTileAtPosition(i.x+this.getDirection(),i.y+this.getDirection()),c=e.getTileAtPosition(i.x+this.getDirection(),i.y-this.getDirection()),h=e.getTileAtPosition(i.x-this.getDirection(),i.y+this.getDirection()),a=e.getTileAtPosition(i.x-this.getDirection(),i.y-this.getDirection());const d=e=>{e&&(!e.currentPiece||e.currentPiece&&e.currentPiece.color!=this.color)&&t.push({x:e.x,y:e.y})};return[s,r,o,n,l,c,h,a].forEach((e=>{d(e)})),t}constructor(...e){super(...e),this.type=()=>"black"==this.color?"♚":"♔"}}class c{getTileAtPosition(e,t){try{return this.boardTiles[t][e]}catch(e){return null}}selectPiece(e,t){return this.selectedPiece=this.getPieceAtPosition(e,t),console.log(this.selectedPiece),this.selectedPiece}getPieceAtPosition(e,t){try{return this.boardTiles[t][e].currentPiece}catch(e){return null}}movePiece(e,t){console.log("moving piece",e,t),t.currentPiece=e.currentPiece,t.currentPiece instanceof r&&(t.currentPiece.hasMoved=!0),e.currentPiece=null,t.currentPiece.currentTile=t}setupDataModel(){for(let e=0;e<8;e++)this.makeRow(e);for(let e=0;e<this.flatTileList.length;e++){const t=this.flatTileList[e];t.prevLight=undefined,e<this.flatTileList.length-1&&(t.nextLight=this.flatTileList[e+1])}this.flatTileList[0].prevLight=this.flatTileList[this.flatTileList.length-1],this.flatTileList[this.flatTileList.length-1].nextLight=this.flatTileList[0]}setupPiecesOnBoard(){this.boardTiles[0][0].currentPiece=new o(this.boardTiles[0][0]),this.boardTiles[0][7].currentPiece=new o(this.boardTiles[0][7]),this.boardTiles[0][1].currentPiece=new s(this.boardTiles[0][1]),this.boardTiles[0][6].currentPiece=new s(this.boardTiles[0][6]),this.boardTiles[0][2].currentPiece=new t(this.boardTiles[0][2]),this.boardTiles[0][5].currentPiece=new t(this.boardTiles[0][5]),this.boardTiles[0][3].currentPiece=new n(this.boardTiles[0][3]),this.boardTiles[0][4].currentPiece=new l(this.boardTiles[0][4]),this.boardTiles[7][0].currentPiece=new o(this.boardTiles[7][0],"black"),this.boardTiles[7][7].currentPiece=new o(this.boardTiles[7][7],"black"),this.boardTiles[7][1].currentPiece=new s(this.boardTiles[7][1],"black"),this.boardTiles[7][6].currentPiece=new s(this.boardTiles[7][6],"black"),this.boardTiles[7][2].currentPiece=new t(this.boardTiles[7][2],"black"),this.boardTiles[7][5].currentPiece=new t(this.boardTiles[7][5],"black"),this.boardTiles[7][3].currentPiece=new l(this.boardTiles[7][3],"black"),this.boardTiles[7][4].currentPiece=new n(this.boardTiles[7][4],"black");for(let e=0;e<8;e++)this.boardTiles[1][e].currentPiece=new r(this.boardTiles[1][e]),this.boardTiles[6][e].currentPiece=new r(this.boardTiles[6][e],"black")}findCurrentlyLit(){return this.flatTileList.filter((e=>e.isOn))}turnOffAll(){this.flatTileList.forEach((e=>e.isOn=!1))}markAllInvalid(){this.flatTileList.forEach((e=>e.isValidPosition=!1))}makeRow(e){this.boardTiles[e]=[];for(let t=0;t<8;t++){const s=new i(this.counter++,t,e);this.boardTiles[e].push(s),this.flatTileList.push(s)}}constructor(){this.boardTiles=[],this.flatTileList=[],this.counter=0,this.currentPlayersTurn="white"}}class h{updatePattern(e){return e.turnOffAll(),e.boardTiles[this.currentlyLitLightRow].forEach((e=>e.isOn=!0)),this.currentlyLitLightRow++,this.currentlyLitLightRow>=e.boardTiles.length&&(this.currentlyLitLightRow=0),e}constructor(){this.currentlyLitLightRow=0}}class a{constructor(){this.firstRun=!0}updatePattern(e){this.firstRun&&(e.turnOffAll(),e.flatTileList[0].isOn=!0,this.firstRun=!1);let t=e.findCurrentlyLit();if(t.length>0)for(let e=t.length-1;0<=e;e--){const i=t[e];i.isOn=!1,i.nextLight.isOn=!0}return e}}class d{updatePattern(e){e.turnOffAll();let t=e.flatTileList[this.snakeHead];t.isOn=!0;let i=t;for(let e=0;e<this.snakeLength;e++)i=i.nextLight,i.isOn=!0,0==e&&(this.snakeHead=i.id);return e}constructor(){this.snakeHead=0,this.snakeLength=12}}new class{constructor(){window.addEventListener("DOMContentLoaded",(()=>{document.getElementById("mode").addEventListener("change",(e=>{this.changeMode(e)})),setInterval((()=>{this.updateDisplay()}),100),this.chessBoard=new c,this.chessBoard.setupDataModel(),this.chessBoard.setupPiecesOnBoard(),this.buildBoard()}))}updateDisplay(){this.mode&&(this.chessBoard=this.mode.updatePattern(this.chessBoard)),this.chessBoard.flatTileList.forEach((e=>{let t=document.getElementById(`tile-${e.id}`);const i=(e.id+1)%2==0?"even":"odd",s=e.isOn?"on":"off";t.className=`chess-tile ${s} ${i}`,e.isOn?t.style.backgroundColor=`hsl(${e.hue}, ${e.saturation}%, ${e.brightness}%)`:t.style.backgroundColor=e.tileBaseColor,e.currentPiece&&(t.style.color=e.currentPiece.color);let r="";e.currentPiece&&(r=e.currentPiece.type()),t.innerHTML=`${r}`}))}changeMode(e){switch(e.target.value){case"snake":this.mode=new d;break;case"sequence":this.mode=new a;break;case"row":this.mode=new h;break;case"none":this.mode=null}}buildBoard(){let e=document.getElementById("chess-board");for(;e.firstChild;)e.removeChild(e.firstChild);this.chessBoard.boardTiles.map((e=>{const t=e.map((e=>{let t=document.createElement("div");t.className=`chess-tile ${e.id%2==0?"even":"odd"}  ${e.isOn?"on":"off"}`,t.id=`tile-${e.id}`;return t.addEventListener("click",(()=>{if(e.isValidPosition)this.chessBoard.movePiece(this.chessBoard.selectedPiece.currentTile,e),this.chessBoard.turnOffAll(),this.chessBoard.markAllInvalid(),this.chessBoard.currentPlayersTurn="white"===this.chessBoard.currentPlayersTurn?"black":"white";else{let t=this.chessBoard.selectPiece(e.x,e.y),i=e.isOn;if(this.chessBoard.turnOffAll(),t&&(e.isOn=!i,e.isOn)){this.chessBoard.markAllInvalid(),t.findValidMoves(this.chessBoard).forEach((e=>{this.chessBoard.getTileAtPosition(e.x,e.y).isValidPosition=!0,this.chessBoard.getTileAtPosition(e.x,e.y).isOn=!0}))}}})),t}));let i=document.createElement("div");return i.className="row",t.forEach((e=>{i.appendChild(e)})),i})).forEach((t=>e.appendChild(t)))}};
//# sourceMappingURL=index.7863f23c.js.map
