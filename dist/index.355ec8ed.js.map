{"mappings":"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","sources":["src/ChessPieces/ChessPiece.ts","src/ChessPieces/Bishop.ts","src/ChessPieces/util.ts","src/ChessTile.ts","src/ChessPieces/Knight.ts","src/ChessPieces/Pawn.ts","src/ChessPieces/Rook.ts","src/ChessPieces/Queen.ts","src/ChessPieces/King.ts","src/Player.ts","src/ChessBoard.ts","src/LightPatterns/RowPattern.ts","src/LightPatterns/SequencePattern.ts","src/LightPatterns/SnakePattern.ts","src/ChessLightsMain.ts"],"sourcesContent":["import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\n\n/**\n * Abstract Base Class for common properties/methods for all of the pieces\n */\nexport default abstract class ChessPiece {\n  abstract pieceSymbol(): string\n  abstract get fenType(): string\n  /**\n   * \n   * @param boardState The current board state to find valid moves on\n   */\n  abstract findValidMoves(boardState: ChessBoard): Array<{ x: number; y: number; }>\n  abstract clone(boardTiles:Array<Array<ChessTile>>): ChessPiece\n  public currentTile: ChessTile = null\n\n  constructor(boardTiles: Array<Array<ChessTile>>, x: number, y: number, public color: \"white\" | \"black\" = \"white\", public hasMoved = false) {\n    boardTiles[x][y].currentPiece = this\n    this.currentTile = boardTiles[x][y]\n  }\n\n  get direction() { return this.color === \"white\" ? 1 : -1 }\n\n  get myPos() {\n    return {\n      x: this.currentTile.x,\n      y: this.currentTile.y\n    }\n  }\n\n  toString() {\n    return `${this.pieceSymbol()}`\n  }\n\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Bishop extends ChessPiece {\n  get fenType(): string {\n    return 'B'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♝\" : \"♗\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n\n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Bishop(boardTiles, this.currentTile.y,this.currentTile.x, this.color)\n  }\n}","export function getRank(index:number){\n  return ['a','b','c','d','e','f','g','h'][index]\n}\nexport function getFile(index:number){\n  return 8-index\n}","import ChessPiece from \"./ChessPieces/ChessPiece\";\nimport {getFile, getRank} from \"./ChessPieces/util\"\n\nexport default class ChessTile {\n    id: number\n    y: number\n    x: number\n    \n    isValidPosition: boolean\n    canKingSideCastle: boolean\n    canQueenSideCastle: boolean\n\n    prevLight: ChessTile;\n    nextLight: ChessTile;\n\n    currentPiece:ChessPiece|null;\n\n    get tileBaseColor () {\n        return (this.id+(this.y%2))%2==0 ? \"black\" : \"white\"\n    }\n\n    constructor(id, x, y, public isOn=false, public hue=0, public saturation=100, public brightness=50) {\n        this.id = id\n        this.x = x\n        this.y = y\n    }\n\n    // Just clones the object with properties needed for checking valid positions\n    // for checking hypothetical board states\n    clone() {\n        return new ChessTile(this.id, this.x, this.y)\n    }\n    toString() {\n        return `${getFile(this.x)}${getRank(this.y)} with Piece ${this.currentPiece}`\n    }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Knight extends ChessPiece {\n  get fenType(): string {\n    return 'N'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♞\" : \"♘\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n    \n    let tileOne = boardState.getTileAtPosition(myPos.x+2, myPos.y+1)\n    let tileTwo = boardState.getTileAtPosition(myPos.x+1, myPos.y+2)\n    let tileThree = boardState.getTileAtPosition(myPos.x-2, myPos.y+1)\n    let tileFour = boardState.getTileAtPosition(myPos.x-1, myPos.y+2)\n    \n    let tileFive = boardState.getTileAtPosition(myPos.x-2, myPos.y-1)\n    let tileSix = boardState.getTileAtPosition(myPos.x-1, myPos.y-2)\n    let tileSeven = boardState.getTileAtPosition(myPos.x+2, myPos.y-1)\n    let tileEight = boardState.getTileAtPosition(myPos.x+1, myPos.y-2);\n\n    [tileOne,tileTwo,tileThree,tileFour,tileFive,tileSix,tileSeven,tileEight].forEach(tile=>{\n      // skip if the tile doesn't exist\n      if(!tile) return;\n      // \n      if(!tile.currentPiece || tile.currentPiece.color != this.color) {\n        validPositions.push(tile)\n      }\n    })\n\n\n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Knight(boardTiles, this.currentTile.y, this.currentTile.x, this.color)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Pawn extends ChessPiece {\n  get fenType(): string {\n    return 'P'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♟︎\" : \"♙\";\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos, direction} = this\n\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    \n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (tile.currentPiece && tile.currentPiece.color!=this.color)) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileTL,tileTR].forEach(tile=>addTilePositionIfValid(tile))\n\n    let pieceOneAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction)\n    if(!pieceOneAhead) {\n      validPositions.push({\n        x: myPos.x,\n        y: myPos.y+direction\n      })\n    }\n\n    // Pawn can move two spots if hasn't moved yet\n    if(!this.hasMoved && !pieceOneAhead) {\n      let twoPiecesAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction*2)\n      if(!twoPiecesAhead) {\n        validPositions.push({\n          x: myPos.x,\n          y: myPos.y+direction*2\n        })\n      }\n    }\n\n    return validPositions;\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Pawn(boardTiles, this.currentTile.y, this.currentTile.x, this.color)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Rook extends ChessPiece {\n  public kingSideRook: boolean = false;\n\n  get fenType(): string {\n    return 'R'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♜\" : \"♖\";\n  \n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    // Destructuring props of this\n    const {myPos} = this\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Rook(boardTiles, this.currentTile.y, this.currentTile.x, this.color)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class Queen extends ChessPiece {\n  get fenType(): string {\n    return 'Q'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♛\" : \"♕\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this;\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new Queen(boardTiles, this.currentTile.y, this.currentTile.x, this.color)\n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ChessTile from \"../ChessTile\";\nimport ChessPiece from \"./ChessPiece\";\n\nexport default class King extends ChessPiece {\n\n  get fenType(): string {\n    return 'K'\n  }\n  pieceSymbol = () => this.color==\"black\" ?  \"♚\" : \"♔\";\n  \n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n\n    const {myPos, direction} = this;\n\n    // Cardinal positions\n    let tileOneAbove = boardState.getTileAtPosition(myPos.x, myPos.y+direction)\n    let tileOneBelow = boardState.getTileAtPosition(myPos.x, myPos.y-direction)\n    let tileOneLeft = boardState.getTileAtPosition(myPos.x-1, myPos.y)\n    let tileOneRight = boardState.getTileAtPosition(myPos.x+1, myPos.y)\n\n    // Diaganol moves\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileBL = boardState.getTileAtPosition(myPos.x+direction, myPos.y-direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    let tileBR = boardState.getTileAtPosition(myPos.x-direction, myPos.y-direction)\n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (!tile.currentPiece || (tile.currentPiece && tile.currentPiece.color!=this.color))) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileOneAbove, tileOneBelow, tileOneLeft, tileOneRight, tileTL, tileBL, tileTR, tileBR].forEach(tile => {\n      addTilePositionIfValid(tile)\n    })\n    \n    return validPositions\n  }\n  \n  clone(boardTiles:Array<Array<ChessTile>>): ChessPiece {\n    return new King(boardTiles, this.currentTile.y, this.currentTile.x, this.color)\n  }\n}","import ChessPiece from \"./ChessPieces/ChessPiece\";\nimport King from \"./ChessPieces/King\";\nimport Rook from \"./ChessPieces/Rook\";\n\nexport default class Player {\n  pieces: Array<ChessPiece> = []\n  inCheck: boolean = false\n  inCheckmate: boolean = false\n  inStalemate: boolean = false\n  canKingSideCastle: boolean = false\n  canQueenSideCastle: boolean = false\n\n  constructor(public color: \"white\" | \"black\") { }\n  \n  get king():King {\n    return this.pieces.find((value,index,obj) => {\n      return value instanceof King\n    }) as King\n  }\n\n  get kingHasMoved() {\n    return this.king.hasMoved\n  }\n\n  get kingSideRook():Rook {\n    return this.pieces.find((value,index,obj) => {\n      return value instanceof Rook && value.kingSideRook\n    }) as Rook\n  }\n\n  get kingSideRookHasMoved() {\n    if(!this.kingSideRook) return true\n    \n    return this.kingSideRook.hasMoved\n  }\n\n  get queenSideRook():Rook {\n    return this.pieces.find((value,index,obj) => {\n      return value instanceof Rook && !value.kingSideRook\n    }) as Rook\n  }\n\n  get queenSideRookHasMoved() {\n    if(!this.queenSideRook) return true\n\n    return this.queenSideRook.hasMoved\n  }\n\n  \n  clone() {\n    return new Player(this.color)\n  }\n  toString() {\n    return `${this.color} player, pieces: ${this.pieces}, in check: ${this.inCheck}, in stalemate: ${this.inStalemate}, in checkmate: ${this.inCheckmate}`\n  }\n}","import Bishop from \"./ChessPieces/Bishop\";\nimport ChessTile from \"./ChessTile\"\nimport Knight from \"./ChessPieces/Knight\";\nimport Pawn from \"./ChessPieces/Pawn\";\nimport Rook from \"./ChessPieces/Rook\";\nimport Queen from \"./ChessPieces/Queen\";\nimport King from \"./ChessPieces/King\";\nimport ChessPiece from \"./ChessPieces/ChessPiece\";\nimport Player from \"./Player\";\nimport ILightPattern from \"./LightPatterns/ILightPattern\";\nimport { getFile, getRank } from \"./ChessPieces/util\";\n\ntype BoardPosition = {\n  x:number\n  y:number\n}\n\n/**\n * Builds the board and keeps track of the game state (selected piece, current player etc)\n * \n * The board is an x/y grid drawn top to bottom left to right\n */\nexport default class ChessBoard {\n  redraw: boolean = true\n  boardTiles: Array<Array<ChessTile>> = []\n  flatTileList: Array<ChessTile> = []\n  players: Array<Player> = []\n  counter = 0\n  selectedPiece: ChessPiece\n\n  //FEN helper props below\n  castlingAvailable = \"-\"\n  // If an enpassant capture is possible the square to move to for the capture or -\n  enPassantSquare = \"-\"\n  // Halfmove clock:\n  // Number of halfmoves since the last capture or pawn move. It's used for the fifty-move rule.\n  numberOfHalfMoves = 0\n  // Starts at 1 and is incremented after Black's move.\n  numberOfFullMoves = 1\n\n  get currentPlayersTurn(): \"white\" | \"black\" {\n    return this.currentPlayer.color\n  }\n  currentPlayer: Player\n  get whitePlayer() {\n    return this.players[0]\n  }\n  get blackPlayer() {\n    return this.players[1]\n  }\n\n  constructor(private targetElement:string, autoSetupPieces:boolean = true) {\n    this.setupDataModel()\n    if(autoSetupPieces)\n      this.setupPiecesOnBoard()\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for tile to get (0-7)\n   * @param y Vetical offset from 0 for tile to get (0-7)\n   * @returns A ChessTile if one exists at the position or null if the position is out of bounds\n   */\n  getTileAtPosition(x: number, y: number): ChessTile | null {\n    try {\n      return this.boardTiles[y][x];\n    } catch (e) {\n      return null\n    }\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for Piece to get (0-7)\n   * @param y Vertical offset from 0 for Piece to get (0-7)\n   * @returns Piece on tile at given position or null if no piece or invalid tile\n   */\n  getPieceAtPosition(x: number, y: number): ChessPiece | null {\n    try {\n      return this.boardTiles[y][x].currentPiece\n    } catch (e) {\n      return null\n    }\n  }\n\n  /**\n   * \n   * @param x Horizontal offset from 0 for Piece to select (0-7)\n   * @param y Vertical offset from 0 for Piece to select (0-7)\n   * @returns The selected piece if a piece existed on the tile at the given position or null if no piece or tile at position\n   */\n  selectPiece(x: number, y: number): ChessPiece | null {\n    // Don't return a piece if a tile has a piece, but the piece isn't the same color as the current player\n    this.selectedPiece = this.getPieceAtPosition(x, y)\n\n    // console.log(`Selected Piece: ${this.selectedPiece} on board: ${this.targetElement}`)\n    return this.selectedPiece\n  }\n\n  isPlayerInCheckAfterClonedBoardMove(fromTile: BoardPosition, toTile: BoardPosition):boolean {\n    let clonedBoardState = this.clone()\n    clonedBoardState.movePiecePosition(fromTile, toTile)\n    clonedBoardState.redraw = true\n    clonedBoardState.updateDisplay()\n    return clonedBoardState.checkIfPlayerIsInCheck()\n  }\n\n  /**\n   * Method will move a piece from one tile to another so long as the move\n   * doesn't put or leave the current player's king in check.\n   * \n   * @param fromTile The tile to move the piece from\n   * @param toTile The tile to move the piece to\n   * @returns [boolean] true if the piece was moved false if it was not\n   */\n  movePiece(fromTile: ChessTile, toTile: ChessTile, withChecking:boolean=true): boolean {\n    console.log(`moving piece from: ${fromTile}, to: ${toTile} on board: ${this.targetElement}`)\n\n    // Cloning the current board so can simulate the move and see if the\n    // current players king is left in check\n    if(withChecking)\n    {\n      let willMovePutPlayerIntoCheck = this.isPlayerInCheckAfterClonedBoardMove(fromTile, toTile)\n      console.log(`will move leave player in check ${willMovePutPlayerIntoCheck}`)\n  \n      if(willMovePutPlayerIntoCheck) return false\n    }\n    \n    const isPlayerPieceOnTile = piece => piece != toTile.currentPiece\n\n    if(toTile.currentPiece) {\n      if(toTile.currentPiece.color==\"white\")\n      this.players[0].pieces = this.players[0].pieces.filter(isPlayerPieceOnTile)\n      if(toTile.currentPiece.color==\"black\")\n      this.players[1].pieces = this.players[1].pieces.filter(isPlayerPieceOnTile)\n    }\n\n    // Moves the selected pieces from the from to tile to the to tile\n    toTile.currentPiece = fromTile.currentPiece\n    toTile.currentPiece.hasMoved = true\n\n    if (toTile.currentPiece instanceof Pawn) {\n      if(toTile.y == 0 || toTile.y==7) {\n        let theNewQueen = new Queen(this.boardTiles, toTile.y, toTile.x, toTile.currentPiece.color)\n        this.currentPlayer.pieces.splice(this.currentPlayer.pieces.indexOf(toTile.currentPiece), 1, theNewQueen)\n        toTile.currentPiece = theNewQueen\n      }\n    }\n\n    fromTile.currentPiece = null\n    toTile.currentPiece.currentTile = toTile\n\n    if(toTile.currentPiece instanceof King){\n      if(toTile.canKingSideCastle) {\n        const kingSideRook = this.currentPlayer.kingSideRook\n        this.movePiecePosition(kingSideRook.currentTile, {x: toTile.x-1, y: toTile.y})\n        kingSideRook.hasMoved = true\n      }\n      if(toTile.canQueenSideCastle) {\n        const queenSideRook = this.currentPlayer.queenSideRook\n        this.movePiecePosition(queenSideRook.currentTile, {x: toTile.x+1, y: toTile.y})\n        queenSideRook.hasMoved = true\n      }\n    }\n\n    return true\n  }\n\n  // This method doesn't depend on being passed the tile itself necessarily it\n  // will use the given position to find the \n  movePiecePosition(fromPosition: BoardPosition, toPosition: BoardPosition) {\n    let fromTile = this.getTileAtPosition(fromPosition.x, fromPosition.y)\n    let toTile = this.getTileAtPosition(toPosition.x, toPosition.y)\n\n    this.movePiece(fromTile, toTile, false)\n  }\n\n  /**\n   * Sets the isValidPosition to false for all tiles\n   */\n  markAllInvalid() {\n    this.flatTileList.forEach(light => light.isValidPosition = false)\n  }\n\n  /**\n   * Sets up the initial data model(s) for the tiles, creates all the rows\n   * that make up the grid of tiles and populates each row with tiles\n   */\n  setupDataModel() {\n    for (let y = 0; y < 8; y++) {\n      this.makeRow(y)\n    }\n\n    // setup link list references between objects\n    let prevLight\n    for (let i = 0; i < this.flatTileList.length; i++) {\n      const currentLight = this.flatTileList[i];\n      currentLight.prevLight = prevLight\n      if (i < this.flatTileList.length - 1) {\n        currentLight.nextLight = this.flatTileList[i + 1]\n      }\n    }\n\n    this.flatTileList[0].prevLight = this.flatTileList[this.flatTileList.length - 1]\n    this.flatTileList[this.flatTileList.length - 1].nextLight = this.flatTileList[0]\n  }\n\n  setupPiecesOnBoard() {\n    // White back row\n    let whiteRook1 = new Rook(this.boardTiles, 0, 0)\n    let whiteKnight1 = new Knight(this.boardTiles, 0, 1)\n    let whiteBishop1 = new Bishop(this.boardTiles, 0, 2)\n    let whiteQueen = new Queen(this.boardTiles, 0, 3)\n    let whiteKing = new King(this.boardTiles, 0, 4)\n    let whiteBishop2 = new Bishop(this.boardTiles, 0, 5)\n    let whiteKnight2 = new Knight(this.boardTiles, 0, 6)\n    let whiteRook2 = new Rook(this.boardTiles, 0, 7)\n    whiteRook2.kingSideRook = true\n\n    // Black back row\n    let blackRook1 = new Rook(this.boardTiles, 7, 0, \"black\")\n    let blackKnight1 = new Knight(this.boardTiles, 7, 1, \"black\")\n    let blackBishop1 = new Bishop(this.boardTiles, 7, 2, \"black\")\n    let blackQueen = new Queen(this.boardTiles, 7, 3, \"black\")\n    let blackKing = new King(this.boardTiles, 7, 4, \"black\")\n    let blackBishop2 = new Bishop(this.boardTiles, 7, 5, \"black\")\n    let blackKnight2 = new Knight(this.boardTiles, 7, 6, \"black\")\n    let blackRook2 = new Rook(this.boardTiles, 7, 7, \"black\")\n    blackRook2.kingSideRook = true\n\n    const whitePawns = []\n    const blackPawns = []\n\n    for (let x = 0; x < 8; x++) {\n      // White pawns\n      const whitePawn = new Pawn(this.boardTiles, 1, x)\n      whitePawns.push(whitePawn)\n\n      // Black pawns\n      const blackPawn = new Pawn(this.boardTiles, 6, x, \"black\")\n      blackPawns.push(blackPawn)\n    }\n\n    const player1 = new Player(\"white\")\n    player1.pieces = [whiteRook1, whiteRook2, whiteKnight1, whiteKnight2, whiteBishop1, whiteBishop2, whiteQueen, whiteKing, ...whitePawns]\n\n    const player2 = new Player(\"black\")\n    player2.pieces = [blackRook1, blackRook2, blackKnight1, blackKnight2, blackBishop1, blackBishop2, blackQueen, blackKing, ...blackPawns]\n\n    this.players = [player1, player2]\n\n    this.currentPlayer = player1\n  }\n\n  changeCurrentPlayer() {\n    this.turnOffAllTileLights();\n    this.markAllInvalid();\n    this.currentPlayer.inCheck = this.checkIfPlayerIsInCheck();\n    console.debug(`checked current player is in check while changing players ${this.currentPlayer}`)\n\n    this.currentPlayer = this.currentPlayer === this.players[0] ? this.players[1] : this.players[0];\n    console.debug(`Switched players is now ${this.currentPlayer} turn`)\n    console.log(this.generateFEN())\n\n    // Checking if the new player is now in check.\n    this.currentPlayer.inCheck = this.checkIfPlayerIsInCheck();\n    if(this.currentPlayer.inCheck) {\n      console.debug(`Checking if ${this.currentPlayer.color} in checkmate`)\n      this.currentPlayer.inCheckmate = this.cannotMakeAnyMoveWithoutLeavingKingInCheck()\n    } else {\n      console.debug(`Checking if ${this.currentPlayer.color} in stalemate`)\n      this.currentPlayer.inStalemate = this.cannotMakeAnyMoveWithoutLeavingKingInCheck()\n    }\n    console.debug(`done with checks:\\n${this.currentPlayer}`)\n    console.log(`Switched players is now ${this.currentPlayer} turn`)\n    if(this.currentPlayer.color === \"white\") {\n      this.numberOfFullMoves++\n    }\n\n    this.numberOfHalfMoves++\n  }\n\n  makeRow(rowNum: number) {\n    this.boardTiles[rowNum] = []\n\n    for (let x = 0; x < 8; x++) {\n      const newLightObject = new ChessTile(this.counter++, x, rowNum)\n\n      this.boardTiles[rowNum].push(newLightObject)\n\n      this.flatTileList.push(newLightObject)\n    }\n  }\n\n  checkIfPlayerIsInCheck(targetPlayer:Player = this.currentPlayer):boolean {\n    const otherPlayer = this.whitePlayer == targetPlayer ? this.blackPlayer : this.whitePlayer\n\n    let kingIsInCheck = false\n    otherPlayer.pieces.forEach(piece => {\n      const validMoves = piece.findValidMoves(this)\n      // If king is in check\n      if(targetPlayer.king && validMoves.find(val => val.x == targetPlayer.king.currentTile.x && val.y == targetPlayer.king.currentTile.y) ) {\n        kingIsInCheck = true\n      }\n    })\n    return kingIsInCheck\n  }\n\n  /**\n   * Will see if moving any of the target player's pieces will result in the\n   * player no longer being in check, will be called only if the target players\n   * king is already known to be in check currently\n   * \n   * @param targetPlayer The player to see if cannot make a move to get out of\n   * check mate\n   */\n  cannotMakeAnyMoveWithoutLeavingKingInCheck(targetPlayer:Player = this.currentPlayer) {\n    // For each of the target players pieces we'll clone the board, make the valid move and see if the player\n    // is in check on the cloned board.\n    let anyMoveGetsKingOutofCheck = false\n    targetPlayer.pieces.forEach(piece => {\n      const clonedBoard = this.clone()\n      const validMoves = piece.findValidMoves(clonedBoard)\n      validMoves.forEach(move => {\n        anyMoveGetsKingOutofCheck = anyMoveGetsKingOutofCheck || !clonedBoard.isPlayerInCheckAfterClonedBoardMove(piece.currentTile, move)\n      })\n    })\n    return !anyMoveGetsKingOutofCheck\n  }\n\n  checkIfCastlingPossible(player:Player = this.currentPlayer) {\n    console.log(\"check for castling\")\n\n    // setting both false until check if can castle on either side\n    player.canKingSideCastle = false\n    player.canQueenSideCastle = false\n\n    if(!player.kingHasMoved && !player.kingSideRookHasMoved) {\n\n      const { x:kingX, y:kingY } = player.king.currentTile\n\n      const tileNextTo = this.getTileAtPosition(kingX+1,kingY)\n      const tileTwoOver = this.getTileAtPosition(kingX+2,kingY)\n      \n      if(tileNextTo?.currentPiece == null && tileTwoOver?.currentPiece == null) {\n        player.canKingSideCastle = true\n        console.log(\"king side castling possible\")\n      }\n\n    }\n\n    if(!player.kingHasMoved && !player.queenSideRookHasMoved) {\n      const { x:kingX, y:kingY } = player.king.currentTile\n\n      const tileNextTo = this.getTileAtPosition(kingX-1,kingY)\n      const tileTwoOver = this.getTileAtPosition(kingX-2,kingY)\n      const tileThreeOver = this.getTileAtPosition(kingX-3,kingY)\n      if(tileNextTo?.currentPiece == null && tileTwoOver?.currentPiece == null && tileThreeOver?.currentPiece == null) {\n        player.canQueenSideCastle = true\n        console.log(\"queen side castling possible\")\n      }\n    }\n  }\n\n  checkIfEnPassantPossible() {\n\n  }\n\n\n  clone() {\n    const clonedBoard = new ChessBoard('hypothetical-board', false)\n\n    // Cloning players so can maniuplate their pieces in new board states\n    clonedBoard.players = this.players.map(player=>player.clone())\n\n    clonedBoard.currentPlayer = this.currentPlayer.color == \"white\" ? clonedBoard.whitePlayer : clonedBoard.blackPlayer\n\n\n    // Cloning board tiles so can manipulate what piece is on what tile without \n    // effecting the actual game being played.\n    clonedBoard.boardTiles = this.boardTiles.map<Array<ChessTile>>((rowOfTiles) => {\n        const newRowOfTiles = rowOfTiles.map(singleTile => {\n          const clonedTile = singleTile.clone()\n          if(singleTile.currentPiece) {\n            clonedTile.currentPiece = singleTile.currentPiece.clone(clonedBoard.boardTiles)\n            if(clonedTile.currentPiece) {\n              if(clonedTile.currentPiece.color == \"black\")\n                clonedBoard.blackPlayer.pieces.push(clonedTile.currentPiece)\n              if(clonedTile.currentPiece.color == \"white\")\n                clonedBoard.whitePlayer.pieces.push(clonedTile.currentPiece)\n            }\n          }\n          return clonedTile\n        })\n        return newRowOfTiles\n    })\n    clonedBoard.selectPiece(this.selectedPiece.currentTile.x, this.selectedPiece.currentTile.y)\n    clonedBoard.tileClickHandler(clonedBoard.selectedPiece.currentTile)\n    clonedBoard.drawInitialBoard()\n    clonedBoard.updateDisplay()\n    return clonedBoard\n  }\n\n  tileClickHandler(tile: ChessTile) {\n\n    // Spot is marked valid then try to make the move with current selected piece\n    if (tile.isValidPosition) {\n\n      // Try to move the piece, if the piece moves successfully then change players\n      if(this.movePiece(this.selectedPiece.currentTile, tile)) {\n        this.changeCurrentPlayer();\n      }\n    }\n    // If we didn't select a valid position to move a piece to check to see if we\n    // selected a new piece\n    else {\n      this.markAllInvalid();\n      let selectedPiece = this.selectPiece(tile.x, tile.y)\n\n      let wasOn = tile.isOn;\n      this.turnOffAllTileLights();\n      this.checkIfCastlingPossible()\n\n\n      if (selectedPiece && selectedPiece.color == this.currentPlayersTurn) {\n        tile.isOn = !wasOn\n        if (tile.isOn) {\n          let validMoves = selectedPiece.findValidMoves(this)\n\n          // King side castling\n          if(selectedPiece instanceof King && this.currentPlayer.canKingSideCastle) {\n            const {x: kingX, y: kingY} = this.currentPlayer.king.currentTile\n            const tileTwoOver = this.getTileAtPosition(kingX+2,kingY)\n            tileTwoOver.canKingSideCastle = true\n\n            validMoves.push(tileTwoOver)\n          }\n          // Queen side castling\n          if(selectedPiece instanceof King && this.currentPlayer.canQueenSideCastle) {\n            const {x: kingX, y: kingY} = this.currentPlayer.king.currentTile\n            const tileTwoOver = this.getTileAtPosition(kingX-2,kingY)\n            tileTwoOver.canQueenSideCastle = true\n\n            validMoves.push(tileTwoOver)\n          }\n\n          validMoves.forEach(validMove => {\n            // Marking all the valid moves for the selected piece on the board\n            let potentialMovePosition = this.getTileAtPosition(validMove.x, validMove.y)\n            if(potentialMovePosition){\n              potentialMovePosition.isValidPosition = true\n              potentialMovePosition.isOn = true\n            }\n          })\n        }\n      }\n    }\n\n    this.redraw = true\n  }\n  \n\n  /**\n   * return Array of currently lit positions\n   */\n  findCurrentlyLit() {\n    return this.flatTileList.filter(element => element.isOn)\n  }\n\n  /**\n   * Sets the isOn property to false for all tiles\n   */\n  turnOffAllTileLights() {\n    this.flatTileList.forEach(tile => {\n      tile.isOn = false\n      tile.canKingSideCastle = false\n      tile.canQueenSideCastle = false\n    })\n  }\n\n  \n  /**\n   * Called on an interval to update the DOM elements that represent the board\n   * visually based on the board model\n   */\n  updateDisplay(lightMode:ILightPattern = null) {\n\n    // If using a lighting mode then update the tile light pattern on each display update\n    if (lightMode) {\n      lightMode.updatePattern(this)\n      this.redraw = true\n    }\n\n    // If chessboard marked for redraw (after moves) update all the tile styles and contents\n    if(this.redraw) {\n      let gameStatusText = \"\"\n\n      if(this.whitePlayer.inCheck)\n        gameStatusText += \"White player is in check. \"\n      if(this.blackPlayer.inCheck)\n        gameStatusText += \"Black player is in check. \"\n\n      if(this.whitePlayer.inCheckmate)\n        gameStatusText = \"White player is in checkmate. GG\"\n      if(this.blackPlayer.inCheckmate)\n        gameStatusText = \"Black player is in checkmate. GG\"\n\n      if(this.whitePlayer.inStalemate || this.blackPlayer.inStalemate)\n        gameStatusText = \"Game is in stalemate. GG\"\n\n      document.getElementById('game-status').innerHTML = gameStatusText\n\n      this.flatTileList.forEach(tile => {\n  \n        let curTileElm = document.getElementById(`${this.targetElement}-tile-${tile.id}`)\n        const onOrOffTile = tile.isOn ? 'on' : 'off'\n  \n        const newClassName = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n        if(curTileElm.className != newClassName)\n        curTileElm.className = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n  \n\n        let curTileSymbolElm = document.getElementById(`${this.targetElement}-tilesymbol-${tile.id}`)\n\n        if (tile.currentPiece) {\n          curTileSymbolElm.style.color = tile.currentPiece.color\n        }\n  \n        let displayText = \"\"\n        if (tile.currentPiece) {\n          displayText = tile.currentPiece.pieceSymbol()\n        }\n  \n        curTileSymbolElm.innerHTML = `${displayText}`\n      })\n      this.redraw = false\n    }\n  }\n\n  /**\n   * Clears out and rebuilds the DOM elements for the board based on the board model\n   * deals with finding valid moves and highlighting cells on the board based on the\n   * board model\n   */\n  drawInitialBoard() {\n    let chessBoard = document.getElementById(this.targetElement)\n\n    // Emptying out the elements from the board container\n    while (chessBoard.firstChild) {\n      chessBoard.removeChild(chessBoard.firstChild);\n    }\n\n    // Maps all the tiles row by row into DOM elements\n    const boardRowDOMElms = this.boardTiles\n      .map((tileRow) => {\n\n        // Maps all the cells of a given row into DOM elements\n        const cells = tileRow.map((tile) => {\n          let tileDiv = document.createElement('div')\n          tileDiv.className = `chess-tile ${tile.id % 2 == 0 ? 'even' : 'odd'}  ${tile.isOn ? 'on' : 'off'} tile-color-${tile.tileBaseColor}`\n          tileDiv.id = `${this.targetElement}-tile-${tile.id}`\n          tileDiv.style.position = \"relative\"\n\n          tileDiv.addEventListener('click', () => { this.tileClickHandler(tile) })\n\n          let tileNumDiv = document.createElement('div')\n          tileNumDiv.style.position = \"absolute\"\n          tileNumDiv.style.top = \"4px\"\n          tileNumDiv.style.left = \"4px\"\n          tileNumDiv.style.fontSize = \"1rem\"\n          tileNumDiv.style.color = \"rgba(255,255,255,.5)\"\n          tileNumDiv.innerHTML = `${getRank(tile.x)}${getFile(tile.y)}`\n          tileDiv.appendChild(tileNumDiv)\n\n\n          let tileSymbolSpan = document.createElement('span')\n          tileSymbolSpan.id = `${this.targetElement}-tilesymbol-${tile.id}`\n          tileDiv.appendChild(tileSymbolSpan)\n\n          return tileDiv\n        })\n        let rowDiv = document.createElement('div')\n        rowDiv.className = 'row'\n        cells.forEach(cell => { rowDiv.appendChild(cell) })\n        return rowDiv\n      })\n    boardRowDOMElms.forEach(boardRowDOMElm => chessBoard.appendChild(boardRowDOMElm))\n\n  }\n\n  generateFEN(): string {\n    let fen = '';\n\n    // Generate piece placement part of FEN\n    for (let rank = 7; rank >= 0; rank--) {\n      let emptySquares = 0;\n\n      for (let file = 0; file < 8; file++) {\n        const tile = this.boardTiles[rank][file];\n\n        if (tile.currentPiece) {\n          if (emptySquares > 0) {\n            fen += emptySquares;\n            emptySquares = 0;\n          }\n\n          // Append piece letter (uppercase for White, lowercase for Black)\n          fen += tile.currentPiece.color === \"white\" ? tile.currentPiece.fenType.toUpperCase() : tile.currentPiece.fenType.toLowerCase();\n        } else {\n          emptySquares++;\n        }\n      }\n\n      if (emptySquares > 0) {\n        fen += emptySquares;\n      }\n\n      if (rank > 0) {\n        fen += '/';\n      }\n    }\n\n    // Add information about active color, castling, en passant, halfmove clock, and fullmove number\n\n    const fenCurPlayerColor = this.currentPlayer.color === \"white\" ? \"w\" : \"b\"\n\n    const {castlingAvailable, enPassantSquare, numberOfFullMoves, numberOfHalfMoves} = this\n\n    fen += ` ${fenCurPlayerColor} ${castlingAvailable} ${enPassantSquare} ${numberOfHalfMoves} ${numberOfFullMoves}`; // Assuming default values for these fields\n\n    return fen;\n  }\n\n  // Castling availability:\n  // 'K' (or 'k') for kingside castling (short).\n  // 'Q' (or 'q') for queenside castling (long).\n  // '-' if neither side can castle.\n  // example KQkq (all castling possible)\n  // example Kq (castling on white possible on king side, castling possible for black on queen side only\n  getCastlingAvailableFEN() {\n    \n  }\n}","import ChessBoard from \"../ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class RowPattern implements ILightPattern {\n    currentlyLitLightRow = 0\n    updatePattern(currentBoard:ChessBoard): void {\n        currentBoard.turnOffAllTileLights()\n\n        currentBoard.boardTiles[this.currentlyLitLightRow].forEach(lightData => lightData.isOn = true)\n        this.currentlyLitLightRow++\n        if(this.currentlyLitLightRow >= currentBoard.boardTiles.length) {\n            this.currentlyLitLightRow = 0\n        }\n    }\n}","import ChessBoard from \"../ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class SequencePattern implements ILightPattern {\n    firstRun = true\n    constructor() {\n    }\n    updatePattern(currentBoard:ChessBoard): void {\n        if(this.firstRun) {\n            currentBoard.turnOffAllTileLights()\n            currentBoard.flatTileList[0].isOn = true\n            this.firstRun = false\n        }\n        let currentlyLit = currentBoard.findCurrentlyLit()\n        \n        if(currentlyLit.length > 0) {\n\n            for (let i = currentlyLit.length - 1; 0 <= i; i--) {\n                const lightData = currentlyLit[i];\n                \n                lightData.isOn = false;\n                lightData.nextLight.isOn = true;\n            }\n        }\n    }\n}","import ChessBoard from \"../ChessBoard\";\nimport ILightPattern from \"./ILightPattern\";\n\nexport class SnakePattern implements ILightPattern {\n    snakeHead = 0\n    snakeLength = 12\n    updatePattern(currentBoard:ChessBoard): void {\n        currentBoard.turnOffAllTileLights()\n\n        let snakeHeadElm = currentBoard.flatTileList[this.snakeHead]\n        snakeHeadElm.isOn = true\n\n        let curLight = snakeHeadElm\n        for (let i = 0; i < this.snakeLength; i++) {\n            curLight = curLight.nextLight\n            curLight.isOn = true\n            if(i==0)\n                this.snakeHead = curLight.id\n        }\n    }\n}","import ChessBoard from \"./ChessBoard\"\nimport ILightPattern from \"./LightPatterns/ILightPattern\"\nimport { RowPattern } from \"./LightPatterns/RowPattern\"\nimport { SequencePattern } from \"./LightPatterns/SequencePattern\"\nimport { SnakePattern } from \"./LightPatterns/SnakePattern\"\n\nexport class ChessLightsMain {\n  chessBoard: ChessBoard\n  mode: ILightPattern\n\n  constructor() {\n    // Waiting for page to be loaded to get the elements on the page and add\n    // listeners/setup the game\n    window.addEventListener('DOMContentLoaded', () => {\n\n      // Listener for the drop down menu\n      document.getElementById('mode').addEventListener('change', (event) => {\n        this.changeMode(event)\n      })\n\n      setInterval(() => {\n        this.chessBoard.updateDisplay(this.mode)\n      }, 100)\n\n      this.chessBoard = new ChessBoard('chess-board')\n      this.chessBoard.drawInitialBoard()\n      // this.mode = new SequencePattern()\n    });\n  }\n\n\n  /**\n   * Method handles drop down change events and creates the corresponding light\n   * pattern/sequence handler.  Used primarily for prototyping LED patterns for\n   * LED chess board.\n   * \n   * @param event an event from the select/options dropdown, the event.target.value is used to determine which Pattern instance to create\n   */\n  changeMode(event) {\n    switch (event.target.value) {\n      case 'snake': this.mode = new SnakePattern()\n        break;\n      case 'sequence': this.mode = new SequencePattern()\n        break;\n      case 'row': this.mode = new RowPattern()\n        break;\n      case 'none': this.mode = null\n        break;\n    }\n  }\n  \n}\nnew ChessLightsMain()"],"names":["$b22d20f8eed3c195$export$2e2bcd8739ae039","boardTiles","x","y","color","hasMoved","this","currentTile","currentPiece","direction","myPos","toString","pieceSymbol","$0d26fdf8bf377e35$export$2e2bcd8739ae039","fenType","findValidMoves","boardState","validPositions","i","j","curTile","getTileAtPosition","push","i1","j1","i2","j2","i3","j3","clone","$22951f0e8b3292c6$export$2b71294f39aa2536","index","$22951f0e8b3292c6$export$8b3ca78f81ec578c","$19302002edd8d79c$export$2e2bcd8739ae039","tileBaseColor","id","isOn","hue","saturation","brightness","$4f1600a5f2f06aab$export$2e2bcd8739ae039","forEach","tile","$f1ffc8d94fc3f9eb$export$2e2bcd8739ae039","tileTL","tileTR","addTilePositionIfValid","pieceOneAhead","getPieceAtPosition","$c374f64110df5620$export$2e2bcd8739ae039","kingSideRook","$1ef2ac3924524536$export$2e2bcd8739ae039","i4","i5","i6","i7","$6364cc4a6fd49207$export$2e2bcd8739ae039","tileOneAbove","tileOneBelow","tileOneLeft","tileOneRight","tileBL","tileBR","$ac5fb69ba5837957$export$2e2bcd8739ae039","pieces","inCheck","inCheckmate","inStalemate","canKingSideCastle","canQueenSideCastle","king","find","value","obj","kingHasMoved","kingSideRookHasMoved","queenSideRook","queenSideRookHasMoved","$b07460e442fde56f$export$2e2bcd8739ae039","currentPlayersTurn","currentPlayer","whitePlayer","players","blackPlayer","targetElement","autoSetupPieces","redraw","flatTileList","counter","castlingAvailable","enPassantSquare","numberOfHalfMoves","numberOfFullMoves","setupDataModel","setupPiecesOnBoard","e","selectPiece","selectedPiece","isPlayerInCheckAfterClonedBoardMove","fromTile","toTile","clonedBoardState","movePiecePosition","updateDisplay","checkIfPlayerIsInCheck","movePiece","withChecking","console","log","willMovePutPlayerIntoCheck","isPlayerPieceOnTile","piece","filter","theNewQueen","splice","indexOf","fromPosition","toPosition","markAllInvalid","light","isValidPosition","makeRow","length","currentLight","prevLight","nextLight","whiteRook1","whiteKnight1","whiteBishop1","whiteQueen","whiteKing","whiteBishop2","whiteKnight2","whiteRook2","blackRook1","blackKnight1","blackBishop1","blackQueen","blackKing","blackBishop2","blackKnight2","blackRook2","whitePawns","blackPawns","whitePawn","blackPawn","player1","player2","changeCurrentPlayer","turnOffAllTileLights","debug","generateFEN","cannotMakeAnyMoveWithoutLeavingKingInCheck","rowNum","newLightObject","targetPlayer","otherPlayer","kingIsInCheck","validMoves","val","anyMoveGetsKingOutofCheck","clonedBoard","move","checkIfCastlingPossible","player","kingX","kingY","tileNextTo","tileTwoOver","tileThreeOver","checkIfEnPassantPossible","map","rowOfTiles","singleTile","clonedTile","tileClickHandler","drawInitialBoard","wasOn","validMove","potentialMovePosition","findCurrentlyLit","element","lightMode","updatePattern","gameStatusText","document","getElementById","innerHTML","curTileElm","onOrOffTile","newClassName","className","curTileSymbolElm","style","displayText","chessBoard","firstChild","removeChild","tileRow","cells","tileDiv","createElement","position","addEventListener","tileNumDiv","top","left","fontSize","appendChild","tileSymbolSpan","rowDiv","cell","boardRowDOMElm","fen","rank","emptySquares","file","toUpperCase","toLowerCase","fenCurPlayerColor","getCastlingAvailableFEN","$665c16453abd97af$export$8f903ef488e4ee0f","currentBoard","currentlyLitLightRow","lightData","$848bce31666e74a9$export$8dceea515d6747fc","firstRun","currentlyLit","$d4542aa2ee8a2b32$export$da9194b27e270081","snakeHeadElm","snakeHead","curLight","snakeLength","window","event","changeMode","setInterval","mode","target"],"version":3,"file":"index.355ec8ed.js.map"}