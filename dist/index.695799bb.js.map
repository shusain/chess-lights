{"mappings":"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","sources":["src/ChessPieces/ChessPiece.ts","src/ChessPieces/Bishop.ts","src/ChessTile.ts","src/ChessPieces/Knight.ts","src/ChessPieces/Pawn.ts","src/ChessPieces/Rook.ts","src/ChessPieces/Queen.ts","src/ChessPieces/King.ts","src/ChessBoard.ts","src/RowPattern.ts","src/SequencePattern.ts","src/SnakePattern.ts","src/ChessLightsMain.ts"],"sourcesContent":["import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\n\n/**\n * Abstract Base Class for common properties/methods for all of the pieces\n */\nexport abstract class ChessPiece {\n  abstract pieceSymbol() : string\n\n  constructor(public currentTile:ChessTile = null, public color: \"white\" | \"black\" = \"white\") {}\n\n  abstract findValidMoves(boardState : ChessBoard) : Array<{ x: number; y: number; }>\n  \n  get direction() { return this.color === \"white\" ? 1 : -1 }\n\n  get myPos(){\n      return {\n        x: this.currentTile.x,\n        y: this.currentTile.y\n      }\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Bishop extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♝\" : \"♗\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n}","import { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessTile {\n    id: number\n    y: number\n    x: number\n    \n    isValidPosition: boolean\n\n    prevLight: ChessTile;\n    nextLight: ChessTile;\n\n    currentPiece:ChessPiece|null;\n\n    get tileBaseColor () {\n        return (this.id+(this.y%2))%2==0 ? \"black\" : \"white\"\n    }\n\n    constructor(id, x, y, public isOn=false, public hue=0, public saturation=100, public brightness=50) {\n        this.id = id\n        this.x = x\n        this.y = y\n    }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Knight extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♞\" : \"♘\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this\n    \n    let tileOne = boardState.getTileAtPosition(myPos.x+2, myPos.y+1)\n    let tileTwo = boardState.getTileAtPosition(myPos.x+1, myPos.y+2)\n    let tileThree = boardState.getTileAtPosition(myPos.x-2, myPos.y+1)\n    let tileFour = boardState.getTileAtPosition(myPos.x-1, myPos.y+2)\n    \n    let tileFive = boardState.getTileAtPosition(myPos.x-2, myPos.y-1)\n    let tileSix = boardState.getTileAtPosition(myPos.x-1, myPos.y-2)\n    let tileSeven = boardState.getTileAtPosition(myPos.x+2, myPos.y-1)\n    let tileEight = boardState.getTileAtPosition(myPos.x+1, myPos.y-2);\n\n    [tileOne,tileTwo,tileThree,tileFour,tileFive,tileSix,tileSeven,tileEight].forEach(tile=>{\n      // skip if the tile doesn't exist\n      if(!tile) return;\n      // \n      if(!tile.currentPiece || tile.currentPiece.color != this.color) {\n        validPositions.push(tile)\n      }\n    })\n\n\n    return validPositions\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Pawn extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♟︎\" : \"♙\";\n  \n  public hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos, direction} = this\n\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    \n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (tile.currentPiece && tile.currentPiece.color!=this.color)) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileTL,tileTR].forEach(tile=>addTilePositionIfValid(tile))\n\n    let pieceOneAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction)\n    if(!pieceOneAhead) {\n      validPositions.push({\n        x: myPos.x,\n        y: myPos.y+direction\n      })\n    }\n\n    // Pawn can move two spots if hasn't moved yet\n    if(!this.hasMoved && !pieceOneAhead) {\n      let twoPiecesAhead = boardState.getPieceAtPosition(myPos.x, myPos.y+direction*2)\n      if(!twoPiecesAhead) {\n        validPositions.push({\n          x: myPos.x,\n          y: myPos.y+direction*2\n        })\n      }\n    }\n\n    return validPositions;\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Rook extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♜\" : \"♖\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    // Destructuring props of this\n    const {myPos} = this\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    return validPositions\n\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class Queen extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♛\" : \"♕\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n    const {myPos} = this;\n\n    // All spaces to one side \"left\"\n    for(let i=myPos.x-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other side \"right\"\n    for(let i=myPos.x+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(i, myPos.y)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to one side \"top\"\n    for(let i=myPos.y-1; i >= 0; i--) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other side \"bottom\"\n    for(let i=myPos.y+1; i < 8; i++) {\n      let curTile = boardState.getTileAtPosition(myPos.x, i)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 1\"\n    for(let i=myPos.x+1, j=myPos.y+1; i < 8 && j<8; i++, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n    \n    // All spaces to other \"diaganol 2\"\n    for(let i=myPos.x-1, j=myPos.y-1; i >= 0 && j >= 0; i--, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    \n    // All spaces to other \"diaganol 3\"\n    for(let i=myPos.x+1, j=myPos.y-1; i < 8 && j >= 0; i++, j--) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    // All spaces to other \"diaganol 4\"\n    for(let i=myPos.x-1, j=myPos.y+1; i >= 0 && j < 8; i--, j++) {\n      let curTile = boardState.getTileAtPosition(i, j)\n      // If we run into the same color stop\n      if(curTile.currentPiece && curTile.currentPiece.color == this.color)\n      break;\n\n      // If we run into a piece with a different color include it and stop\n      if(curTile.currentPiece && curTile.currentPiece.color != this.color) {\n        validPositions.push(curTile)\n        break\n      }\n      else if(curTile) {\n        validPositions.push(curTile)\n      }\n    }\n\n    return validPositions\n  }\n}","import { ChessBoard } from \"../ChessBoard\";\nimport { ChessTile } from \"../ChessTile\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport default class King extends ChessPiece {\n  pieceSymbol = () => this.color==\"black\" ?  \"♚\" : \"♔\";\n  \n  hasMoved:boolean;\n\n  findValidMoves(boardState:ChessBoard): Array<{ x: number; y: number; }> {\n    const validPositions:Array<{x:number, y:number}> = []\n\n    const {myPos, direction} = this;\n\n    // Cardinal positions\n    let tileOneAbove = boardState.getTileAtPosition(myPos.x, myPos.y+direction)\n    let tileOneBelow = boardState.getTileAtPosition(myPos.x, myPos.y-direction)\n    let tileOneLeft = boardState.getTileAtPosition(myPos.x-1, myPos.y)\n    let tileOneRight = boardState.getTileAtPosition(myPos.x+1, myPos.y)\n\n    // Diaganol moves\n    let tileTL = boardState.getTileAtPosition(myPos.x+direction, myPos.y+direction)\n    let tileBL = boardState.getTileAtPosition(myPos.x+direction, myPos.y-direction)\n    let tileTR = boardState.getTileAtPosition(myPos.x-direction, myPos.y+direction)\n    let tileBR = boardState.getTileAtPosition(myPos.x-direction, myPos.y-direction)\n\n    const addTilePositionIfValid = (tile:ChessTile) => {\n      if(tile && (!tile.currentPiece || (tile.currentPiece && tile.currentPiece.color!=this.color))) {\n        validPositions.push({x:tile.x,y:tile.y})\n      }\n    }\n\n    [tileOneAbove, tileOneBelow, tileOneLeft, tileOneRight, tileTL, tileBL, tileTR, tileBR].forEach(tile => {\n      addTilePositionIfValid(tile)\n    })\n    \n    return validPositions\n  }\n}","import Bishop from \"./ChessPieces/Bishop\";\nimport { ChessTile } from \"./ChessTile\"\nimport Knight from \"./ChessPieces/Knight\";\nimport Pawn from \"./ChessPieces/Pawn\";\nimport Rook from \"./ChessPieces/Rook\";\nimport Queen from \"./ChessPieces/Queen\";\nimport King from \"./ChessPieces/King\";\nimport { ChessPiece } from \"./ChessPieces/ChessPiece\";\n\nexport class ChessBoard {\n    boardTiles: Array<Array<ChessTile>> = []\n    flatTileList:Array<ChessTile> = []\n\n    counter = 0\n    currentPlayersTurn: \"white\" | \"black\" = \"white\"\n    selectedPiece : ChessPiece\n\n    getTileAtPosition(x:number, y:number): ChessTile|null {\n        try {\n            return this.boardTiles[y][x];\n        } catch(e) {\n            return null\n        }\n    }\n\n    selectPiece(x:number, y:number): ChessPiece|null {\n        // Don't return a piece if a tile has a piece, but the piece isn't the same color as the current player\n        this.selectedPiece = this.getPieceAtPosition(x,y)\n        console.log(this.selectedPiece)\n        return this.selectedPiece\n    }\n    \n    getPieceAtPosition(x:number, y:number): ChessPiece|null {\n        try {\n            return this.boardTiles[y][x].currentPiece\n        } catch(e){\n            return null\n        }\n    }\n\n    movePiece(fromTile:ChessTile, toTile:ChessTile):void {\n        console.log('moving piece',fromTile, toTile)\n\n        toTile.currentPiece = fromTile.currentPiece\n        \n        if(toTile.currentPiece instanceof Pawn) {\n            toTile.currentPiece.hasMoved = true\n        }\n\n        fromTile.currentPiece = null\n        toTile.currentPiece.currentTile = toTile\n    }\n\n    setupDataModel() {\n        for (let y = 0; y < 8; y++) {\n            this.makeRow(y)\n        }\n\n        // setup link list references between objects\n        let prevLight\n        for (let i = 0; i < this.flatTileList.length; i++) {\n            const currentLight = this.flatTileList[i];\n            currentLight.prevLight = prevLight\n            if(i < this.flatTileList.length - 1) {\n                currentLight.nextLight = this.flatTileList[i+1]\n            }\n        }\n\n        this.flatTileList[0].prevLight = this.flatTileList[this.flatTileList.length - 1]\n        this.flatTileList[this.flatTileList.length - 1].nextLight = this.flatTileList[0]\n    }\n\n    setupPiecesOnBoard() {\n        // White back row\n        this.boardTiles[0][0].currentPiece = new Rook(this.boardTiles[0][0])\n        this.boardTiles[0][7].currentPiece = new Rook(this.boardTiles[0][7])\n\n        this.boardTiles[0][1].currentPiece = new Knight(this.boardTiles[0][1])\n        this.boardTiles[0][6].currentPiece = new Knight(this.boardTiles[0][6])\n\n        this.boardTiles[0][2].currentPiece = new Bishop(this.boardTiles[0][2])\n        this.boardTiles[0][5].currentPiece = new Bishop(this.boardTiles[0][5])\n\n        this.boardTiles[0][3].currentPiece = new Queen(this.boardTiles[0][3])\n        this.boardTiles[0][4].currentPiece = new King(this.boardTiles[0][4])\n\n        \n        // Black back row\n        this.boardTiles[7][0].currentPiece = new Rook(this.boardTiles[7][0], \"black\")\n        this.boardTiles[7][7].currentPiece = new Rook(this.boardTiles[7][7], \"black\")\n\n        this.boardTiles[7][1].currentPiece = new Knight(this.boardTiles[7][1], \"black\")\n        this.boardTiles[7][6].currentPiece = new Knight(this.boardTiles[7][6], \"black\")\n\n        this.boardTiles[7][2].currentPiece = new Bishop(this.boardTiles[7][2], \"black\")\n        this.boardTiles[7][5].currentPiece = new Bishop(this.boardTiles[7][5], \"black\")\n\n        this.boardTiles[7][4].currentPiece = new King(this.boardTiles[7][4], \"black\")\n        this.boardTiles[7][3].currentPiece = new Queen(this.boardTiles[7][3], \"black\")\n\n        for(let x=0; x < 8; x++) {\n            // White pawns\n            this.boardTiles[1][x].currentPiece = new Pawn(this.boardTiles[1][x])\n\n            // Black pawns\n            this.boardTiles[6][x].currentPiece = new Pawn(this.boardTiles[6][x], \"black\")\n        }\n    }\n    \n    /**\n     * return Array of currently lit positions\n     */\n    findCurrentlyLit() {\n        return this.flatTileList.filter(element => element.isOn )\n    }\n\n    turnOffAll() {\n        this.flatTileList.forEach(light => light.isOn = false)\n    }\n\n    markAllInvalid() {\n        this.flatTileList.forEach(light => light.isValidPosition = false)\n    }\n\n    makeRow(rowNum: number) {\n        this.boardTiles[rowNum] = []\n\n        for (let x = 0; x < 8; x++) {\n            const newLightObject = new ChessTile(this.counter++, x, rowNum)\n\n            this.boardTiles[rowNum].push(newLightObject)\n\n            this.flatTileList.push(newLightObject)\n        }\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class RowPattern implements ILightPattern {\n    currentlyLitLightRow = 0\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        currentBoard.boardTiles[this.currentlyLitLightRow].forEach(lightData => lightData.isOn = true)\n        this.currentlyLitLightRow++\n        if(this.currentlyLitLightRow >= currentBoard.boardTiles.length) {\n            this.currentlyLitLightRow = 0\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SequencePattern implements ILightPattern {\n    firstRun = true\n    constructor() {\n    }\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        if(this.firstRun) {\n            currentBoard.turnOffAll()\n            currentBoard.flatTileList[0].isOn = true\n            this.firstRun = false\n        }\n        let currentlyLit = currentBoard.findCurrentlyLit()\n        \n        if(currentlyLit.length > 0) {\n\n            for (let i = currentlyLit.length - 1; 0 <= i; i--) {\n                const lightData = currentlyLit[i];\n                \n                lightData.isOn = false;\n                lightData.nextLight.isOn = true;\n            }\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\";\nimport { ILightPattern } from \"./ILightPattern\";\n\nexport class SnakePattern implements ILightPattern {\n    snakeHead = 0\n    snakeLength = 12\n    updatePattern(currentBoard:ChessBoard): ChessBoard {\n        currentBoard.turnOffAll()\n\n        let snakeHeadElm = currentBoard.flatTileList[this.snakeHead]\n        snakeHeadElm.isOn = true\n\n        let curLight = snakeHeadElm\n        for (let i = 0; i < this.snakeLength; i++) {\n            curLight = curLight.nextLight\n            curLight.isOn = true\n            if(i==0)\n                this.snakeHead = curLight.id\n        }\n        return currentBoard\n    }\n}","import { ChessBoard } from \"./ChessBoard\"\nimport { ILightPattern } from \"./ILightPattern\"\nimport { RowPattern } from \"./RowPattern\"\nimport { SequencePattern } from \"./SequencePattern\"\nimport { SnakePattern } from \"./SnakePattern\"\n\nexport class ChessLightsMain {\n    chessBoard:ChessBoard\n    mode: ILightPattern\n\n    constructor() {\n        // Waiting for page to be loaded to get the elemnets on the page and add listeners/setup the game\n        window.addEventListener('DOMContentLoaded', () => {\n\n            // Listener for the drop down menu\n            document.getElementById('mode').addEventListener('change', (event) => {\n                this.changeMode(event)\n            })\n\n            setInterval(() => {\n                this.updateDisplay()\n            }, 100)\n\n            this.chessBoard = new ChessBoard()\n            this.chessBoard.setupDataModel()\n            this.chessBoard.setupPiecesOnBoard()\n            this.buildBoard()\n            // this.mode = new SequencePattern()\n        });\n    }\n\n    /**\n     * Called on an interval to update the DOM elements that represent the board visually based on the board model\n     */\n    updateDisplay() {\n        if(this.mode) {\n            this.chessBoard = this.mode.updatePattern(this.chessBoard)\n        }\n\n        this.chessBoard.flatTileList.forEach(tile => {\n\n            let curTileElm = document.getElementById(`tile-${tile.id}`)\n            const onOrOffTile = tile.isOn ? 'on':'off'\n            curTileElm.className = `chess-tile ${onOrOffTile} tile-color-${tile.tileBaseColor}`\n            \n            if(tile.currentPiece) {\n                curTileElm.style.color = tile.currentPiece.color\n            }\n\n            let displayText = \"\"\n            if(tile.currentPiece) {\n                displayText = tile.currentPiece.pieceSymbol()\n            }\n\n            curTileElm.innerHTML = `${displayText}`\n        })\n    }\n\n    /**\n     * Method handles drop down change events and creates the corresponding light pattern/sequence handler.  Used primarily for prototyping LED patterns for LED chess board.\n     * \n     * @param event an event from the select/options dropdown, the event.target.value is used to determine which Pattern instance to create\n     */\n    changeMode(event) {\n        switch(event.target.value) {\n            case 'snake': this.mode = new SnakePattern()\n            break;\n            case 'sequence': this.mode = new SequencePattern()\n            break;\n            case 'row': this.mode = new RowPattern()\n            break;\n            case 'none': this.mode = null\n            break;\n        }\n    }\n\n    /**\n     * Clears out and rebuilds the DOM elements for the board based on the board model\n     * deals with finding valid moves and highlighting cells on the board based on the\n     * board model\n     */\n    buildBoard() {\n        let chessBoard = document.getElementById('chess-board')\n        \n        while (chessBoard.firstChild) {\n            chessBoard.removeChild(chessBoard.firstChild);\n        }\n\n        // Maps all the tiles row by row into DOM elements\n        const boardRowDOMElms = this.chessBoard.boardTiles\n            .map((tileRow) => {\n\n                // Maps all the cells of a given row into DOM elements\n                const cells = tileRow.map((tile) => {\n                    let tileDiv = document.createElement('div')\n                    tileDiv.className = `chess-tile ${tile.id % 2 == 0 ? 'even':'odd'}  ${tile.isOn ? 'on':'off'} tile-color-${tile.tileBaseColor}`\n                    tileDiv.id=`tile-${tile.id}`\n\n                    let tileClickHandler = () => {\n                        if(tile.isValidPosition) {\n                            this.chessBoard.movePiece(this.chessBoard.selectedPiece.currentTile, tile)\n                            this.chessBoard.turnOffAll();\n                            this.chessBoard.markAllInvalid();\n                            this.chessBoard.currentPlayersTurn = this.chessBoard.currentPlayersTurn === \"white\" ? \"black\" : \"white\";\n                        }\n                        else {\n                            this.chessBoard.markAllInvalid();\n                            let selectedPiece = this.chessBoard.selectPiece(tile.x, tile.y)\n                            let wasOn = tile.isOn;\n                            \n                            this.chessBoard.turnOffAll();\n                            \n                            if(selectedPiece) {\n                                tile.isOn = !wasOn\n                                if(tile.isOn) {\n                                    let validMoves = selectedPiece.findValidMoves(this.chessBoard)\n    \n                                    validMoves.forEach(validMove => {\n                                        // Marking all the valid moves for the selected piece on the board\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isValidPosition = true\n                                        this.chessBoard.getTileAtPosition(validMove.x, validMove.y).isOn = true\n                                    })\n                                }\n                            }\n                        }\n                    }\n\n                    tileDiv.addEventListener('click', tileClickHandler)\n                    return tileDiv\n                })\n                let rowDiv = document.createElement('div')\n                rowDiv.className = 'row'\n                cells.forEach(cell => {rowDiv.appendChild(cell)})\n                return rowDiv\n            })\n        boardRowDOMElms.forEach(boardRowDOMElm => chessBoard.appendChild(boardRowDOMElm))\n        \n    }\n}\nnew ChessLightsMain()"],"names":["$b22d20f8eed3c195$export$57e01e9070034a96","currentTile","color","direction","this","myPos","x","y","$0d26fdf8bf377e35$export$2e2bcd8739ae039","findValidMoves","boardState","validPositions","i","j","curTile","getTileAtPosition","currentPiece","push","i1","j1","i2","j2","i3","j3","pieceSymbol","$19302002edd8d79c$export$a9149a6cae1863c8","tileBaseColor","id","isOn","hue","saturation","brightness","$4f1600a5f2f06aab$export$2e2bcd8739ae039","forEach","tile","$f1ffc8d94fc3f9eb$export$2e2bcd8739ae039","tileTL","tileTR","addTilePositionIfValid","pieceOneAhead","getPieceAtPosition","hasMoved","$c374f64110df5620$export$2e2bcd8739ae039","$1ef2ac3924524536$export$2e2bcd8739ae039","i4","i5","i6","i7","$6364cc4a6fd49207$export$2e2bcd8739ae039","tileOneAbove","tileOneBelow","tileOneLeft","tileOneRight","tileBL","tileBR","$b07460e442fde56f$export$e27bc415f35efa4e","boardTiles","e","selectPiece","selectedPiece","console","log","movePiece","fromTile","toTile","setupDataModel","makeRow","flatTileList","length","currentLight","prevLight","nextLight","setupPiecesOnBoard","findCurrentlyLit","filter","element","turnOffAll","light","markAllInvalid","isValidPosition","rowNum","newLightObject","counter","currentPlayersTurn","$8185acef96710cad$export$8f903ef488e4ee0f","updatePattern","currentBoard","currentlyLitLightRow","lightData","$c1f9aa21b345dcac$export$8dceea515d6747fc","firstRun","currentlyLit","$4d5ca11e6b9118b1$export$da9194b27e270081","snakeHeadElm","snakeHead","curLight","snakeLength","window","addEventListener","document","getElementById","event","changeMode","setInterval","updateDisplay","chessBoard","buildBoard","mode","curTileElm","onOrOffTile","className","style","displayText","innerHTML","target","value","firstChild","removeChild","map","tileRow","cells","tileDiv","createElement","wasOn","validMove","rowDiv","cell","appendChild","boardRowDOMElm"],"version":3,"file":"index.695799bb.js.map"}